---
title: Computer Science project.
author: Maksims Kovalovs
header-includes:
- \usepackage{fancyhdr}
- \usepackage{lipsum}
- \pagestyle{fancy}
- \fancyhead[CO,CE]{Maksims Kovalovs -insert candidate num here-}
- \fancyfoot[CO,CE]{Chilwell School 28210}
- \fancyfoot[LE,RO]{\thepage}
output:
    html_document:
        toc: true
        toc_depth: 2
bibliography: references.bib
link-citations: yes
csl: refstyle.csl
---

# Analysis

## Introduction

 Even though the video game industry didn't exist 4 decades ago, it is now one of the most popular hobbies of youth. With new variations idea like mobile games and virtual reality games, it is likely that these games are here to stay for a long time. This project is about making an 8 ball pool game with a top down view that can be played by 2 players on the same computer.

## Existing Solutions

Most pool games online are hosted on online game websites like www.miniclip.com. At the time of writing this, the 8 ball pool game is the top game on the website and google says that the game was reviewed 1,563,388 times (Figure 1). This shows that there is a market for these types of games. The problem is, online websites don't provide the source code for their games which means that the users cannot learn about how the physics of the game work, but also the users won't be able to customize the game options like ball size or color.

![The first result of Google search of "pool game"](figures/miniclip_reviews.png)

I've looked on GitHub for pool games and there were some projects like mine, but most of the projects  were abandoned or unfinished [@githubpool1]. For example, the user raysmith619 has a similar repository. In his README file he says that the game is missing the pockets, friction and ball rotation animations. I see these things as very important to the game and will implement them.

There is a big pool game project written in Ruby on Rails[@githubpool2]. The project is finished however, there are different problems with this project. Looking at the issues page (Figure 1) of the projects, some users are having problems installing the software[@githubissue].

![People having problems installing the pool game (GitHub issue)](figures/installation_problems.png)

Additionally, looking at commit messages (Figure 2), you can see that the main maintainer was trying, albeit unsuccessfully, to add advertisements to the game, which is a bad idea because ads will make the user experience worse[@githubads].

![GitHub commit message](figures/ads.png)

To summarise, my game should have parts the mentioned games didn't have - pockets, friction and ball rotation animations. The game should come with an instruction of how to install the game, so that users could acquire the game easily. Also, there should be a configuration file, so that some properties of the game objects could be changed, e.g. ball size or ball colour.

## Evidence of Analysis

To get more insight to the problem I had to solve and to understand which features I had to implement, I decided to interview one of my sixth form classmates about it:

__What are the problems with the current system?__

_We were supposed to have a pool table installed in the common room this year, but the student union didn't have enough money to do that. Our group has a lot of free time in school, and we really want to play pool against each other, even if it's on a computer._

__Have you found anything online which works as you want?__

_We have found some pool games online, but most of them are player vs AI and require internet connection, which, unfortunately, you can't take for granted. In our case we don't really need to be able to play via the internet, an offline game should be fine._

__Is there anything specific you want in the game?__

_A normal pool game with rules for 2 players should suffice. It shouldn't be too slow or lag. Obviously, the balls and their movement should look like in real life. It would be interesting to have a sandbox or something which allows the user to tweak with the game options like the initial position of the balls._

The user asked for standard features for this type of game, except for the sandbox mode. That can be achieved in different ways, like an in-game GUI or a configuration file, which is present in many new games.

## Identification of End Users

The main end users of this project are my school friends who are interested in playing a computer version of pool. The code will include the physical formulas of collisions and friction, and because this project will open-source and available online, this game might help other people to understand how 2-dimensional ball physics work.

## Proposed Solution

The aim of the project is to build a pool game. Looking at other games online, it would be wise to add a user interface, however there aren't a lot of features which complement a user interface (like save games or in-game soundtrack), so the user interface could be minimal. The user interface will include a main menu and in-game game state trackers (things like current player labels). The collisions and friction will be will have physical models (outlined later in this section). The game will be played on a single computer, with players taking turns to make their move.  Finally, the user interview revealed a need for some sort of configuration option in the game. I think the best way to achieve that would be a configuration file, which is a text file with all of the constant variables in it. That way, if the user wants to change the color of a particular ball, they would be able to do it by changing a variable in the configuration file. This method is easy to implement and provides the highest level of customization possible.

This project will deal with 3d rendering, physical simulation and game development areas of computer science. Therefore, I researched some of the relevant techniques game developers use to create games.

### Collisions

To simulate ball collisions, every frame the game will check for these collisions by comparing the distances between ball centres, and if it detects any, it will resolve the collision based on the velocity and the position of the balls using linear algebra and vector operations. To model ball-ball and ball-table side collisions I can use the inelastic collision formula[@inelasticcollision]. The formula depends on the coefficient of restitution - $e$, whose values range from 0 to 1 (1 being a perfectly elastic collision and 0 perfectly inelastic). Low values of $e$ mean that there is a lot of kinetic energy lost in collision and visa versa.

### Rendering
Some parts of the balls (like the white stripe around the balls) can be modeled as 3d objects and rotated using rotation matrices when the ball is moving and then projected on the table (into a 2d space). Matrices are rectangular arrays which enable us to do spacial transformations of objects. Here is an example of a matrix:

$$
\begin{bmatrix}
    1 & 2 & 0 \\
    2 & 8 & 2 \\
\end{bmatrix}
$$

Matrices are very useful when you want to manipulate vectors in space. For example, this matrix:

$$
\begin{bmatrix}
    cos(\theta) & -sin(\theta) \\
    sin(\theta) & cos(\theta) \\
\end{bmatrix}
$$

rotates points about the origin through an angle $\theta$ counterclockwise. To rotate a vector by the matrix, you must do matrix multiplication. If you have 2 matrices $A$ and $B$, the matrix multiple $C$ is defined like this:

$$
A=
\begin{bmatrix}
    a_{11}&a_{12}&\cdots &a_{1m}\\
    a_{21}&a_{22}&\cdots &a_{2m}\\
    \vdots &\vdots &\ddots &\vdots \\
    a_{n1}&a_{n2}&\cdots &a_{nm}\\
\end{bmatrix}
,B=
\begin{bmatrix}
    b_{11}&b_{12}&\cdots &b_{1p}\\
    b_{21}&b_{22}&\cdots &b_{2p}\\
    \vdots &\vdots &\ddots &\vdots \\
    b_{m1}&b_{m2}&\cdots &b_{mp}\\
\end{bmatrix}
$$
$$
AB=
\begin{bmatrix}
    c_{11}&c_{12}&\cdots &c_{1p}\\
    c_{21}&c_{22}&\cdots &c_{2p}\\
    \vdots &\vdots &\ddots &\vdots \\
    c_{n1}&c_{n2}&\cdots &c_{np}\\
\end{bmatrix}
$$
Or
$$
c_{ij}=a_{i1}b_{1j}+\cdots +a_{im}b_{mj}=\sum_{k=1}^{m}a_{ik}b_{kj}
$$
So, for example, if you have a point in 2-dimensional space $\vec k=(1,2)$ which you want to rotate 90 degrees counterclockwise, you compute:

$$
\begin{bmatrix}
    cos(90) & -sin(90) \\
    sin(90) & cos(90) \\
\end{bmatrix}
\begin{bmatrix}
    1 \\
    2 \\
\end{bmatrix}
=
\begin{bmatrix}
    -2 \\
    1 \\
\end{bmatrix}
$$

You can see the rotation represented on a 2d plane on Figure 3.

![Rotation in 2d plane](figures/rotation.png)

### Friction
To model rolling friction I can use the formula $F=C_{rr}N$ where $C_{rr}$ is the coefficient of rolling resistance of the balls[@rollingfriction]. That means the balls will have a constant frictional force on them (when they are moving).

### Language Choice
At the beginning of the project, I was experienced in two programming languages - Python and Pascal. To pick one, I had to do some research on their suitability for the job.

The programming language of my choice should be able to deal with matrix manipulations outlined earlier. Both languages support array data structures, however, Python has a numerical computations library - Numpy[@numpy]. This library has implemented functions for matrix operations, like matrix multiplication and more.

According to the Tiobe Index[@tiobe] and PYPL[@pypl], Python is significantly more popular than Pascal and hence is a better language to use due to more resources available online (e.g. more StackOverlow questions/answers). This also suggests that python will have higher quality/variety of libraries due to a larger community. Additionally, Python is a duck-typed language, which means no explicit type declarations are required. This makes Python less verbose and more flexible, allowing for faster development, which is beneficial given a limited amount of time for development.

Finally, a game development library will be at the core of my project so it is important to pick a language with a mature, well maintained game development framework. A number of resources list the most popular libraries used for implementing games in Pascal[@fpcgameengine][@delphigamedev]. All of these libraries are either missing completely (home page is broken), seriously outdated or are very immature. At the same time, Python has Pygame[@pygamegithub] which is open source, actively maintained (at the time of writing last commit 3 days ago) and mature (3k commits with 40 contributors).

## Objectives

* The rules of pool should be implemented in the game
* The game should run at more than 30 frames per second
* Physical interactions in the game should be realistic:
  * The movement of the balls should be affected by friction
  * The ball collisions should be inelastic
  * The game should detect and resolve ball-ball and ball-table side collisions
* Game animations look realistic:
  * The balls should visibly rotate when moving
  * The cue should move towards the ball when a player is hitting a ball
* A configuration file, which can change some of the in-game options like ball size or cue hit power
* An installation guide/README file for users

## Acceptable Limitations

After researching the multiplayer feature, I think it will be unfeasible for me to implement it alone. Implementing multiplayer will require good theoretical knowledge of networking and sockets, but the main problem is that adding multiplayer will add a lot of validation problems between clients. Additionally, this feature would most likely require a server, which I don't have.

# Documented Design

## User Interface

A good pool game should implement the following features:

* The game screen should be big enough to see everything clearly.
* The balls should look realistic, and have easily distinguishable stripes on them so the players would not be confused which balls they need to pot.
* The game should have aiming lines to help the player aim. These lines are needed because in real life the player can line up the ball and see where it will go, so the game should have similar functionality.
* The game should have a minimal game menu with a button to start the game and leave the game.

![main menu model](figures/main_menu.png)

In-game interface will consist of the cue, which can be aimed and retracted back to make a shot. The game will also have some indicators of the state of the game:

* A "current player" indicator, which can just be a label on the top
* An indicator of which group of balls the players need to pot to win the game
* An indicator of whether the current player can move the cue ball

![ingame GUI design](figures/ui_example1.png)

### Modular Design

* Main menu
  * The game
    * Stop the game
    * Game over
  * Quit the game

### Controls

* The user will use the mouse to move the cue or the cue ball (if it is movable).
* In the menu the main input method is the mouse, however the user should be able to quit the game by pressing ESC key.
* While in game, the user should be able to press the ESC button to leave to the main menu.

### Pool Rules
To implement the rules of pool I went online and read about the game rules[@poolrules], here are the main points:

* The first break should be performed behind the white line on the table, and the ball may be placed anywhere behind that line.
* If the players haven't decided which group of balls they are on, and the player pots a ball or several balls of a particular group, that player now is on that group.
* To win the game, you must pot the 8 ball legally.
* You must first sink every ball from the group you are on, to pot the 8 ball.
* Failure to hit a ball from your group on your first ball hit, or not hitting a ball at all on your turn, gives your opponent a hit from his hand (which means that he is allowed to put the white ball anywhere on the table)
* If you pot the 8 ball illegally, you lose the game.


## Algorithms

### The main game loop

Pseudocode:

```
while True:
    while not game_is_over():
        resolve_collisions()
        move_everything()
        redraw_everything()

        if all_balls_stopped():
            apply_pool_rules()
            wait_for_cue_hit()
```

This is the whole game split into functions. Every turn, one player uses the cue, then while the balls are moving, the game will check for any collisions, resolve them and do one frame, meaning it will move every moving object and redraw everything. The main game loop will continue doing that until the game is over or the game is closed.

![game flow](figures/game_flowchart.png)

### Rendering

The ball can be split in 3 parts which must be rendered separately:

* The ball stripe
* The label (circle with the number)
* The solid color body

![Initial position of the ball](figures/ball1.png)

![A rotated position of the ball](figures/ball2.png)

A sphere of a solid color will look like a circle from any angle in 2-dimensions. That's why we don't need to worry about any rotations of the solid sphere component. Hence we can just draw the solid body as a solid circle and draw everything else on top.

The stripe on the ball will be modelled as a sequence of connected lines, forming a circle. The lines will be represented with an array of vectors $a$ marking the start/end points of the lines.
$$
a=
\begin{bmatrix}
    \vec k_{1}, & \vec k_{2}, & \vec k_{3}, & \dots, & \vec k_{n}
\end{bmatrix}
$$

Where $\vec k_n$ is a 3d vector on the surface of the ball. We will draw lines from $\vec k_1$ to $\vec k_2$, from $\vec k_2$ to $\vec k_3$ and so on for every adjacent pair of points (a line from $\vec k_{i-1}$ to $\vec k_{i}$ for $i\in[2,n]$). This will draw a polygon that very closely follows the shape of the stripe.

When a ball rotates, the points representing the ball's stripe are transformed accordingly by multiplying them with a rotation matrix. A 3d rotation matrix can be calculated from a rotation axis and an angle through which the ball needs to be rotated. We know the axis of rotation - it is the line perpendicular to the velocity vector and parallel to the table surface, and the angle of rotation is calculated using the formula
$$
\theta=\frac{vt}{r}
$$
where $v$ is the linear speed of the ball and $r$ is the radius of the ball with $\theta$ being in radians. The intuition for the formula is that when the ball is moving, every point on the circumference must touch the ground before it does a full rotation, therefore it must move $2\pi r$ units for a full rotation. The angle the ball has rotated is therefore given by $\theta = \frac{S}{r}$, where $S$ is the linear distance the ball has traveled. Then we substitute the formula $S=vt$ to get the aforementioned formula.

The rotation matrices are calculated using the Euler–Rodrigues formula. The rotated vector $\vec k\prime$ is calculated according to this formula:
$$
\vec k\prime =
\begin{bmatrix}
    a^2+b^2-c^2-d^2 & 2(bc-ad) & 2(bd+ac) \\
    2(bc+ad) & a^2+b^2-c^2-d^2 & 2(cd-ab) \\
    2(bd-ac) & 2(cd+ab) & a^2+b^2-c^2-d^2
\end{bmatrix}
\vec k
$$

Where $a,b,c,d$ are

\begin{gather*}
a = cos(\frac{\phi}{2}) \\
b = v_{x}sin(\frac{\phi}{2}) \\
c = v_{y}sin(\frac{\phi}{2}) \\
d = v_{z}sin(\frac{\phi}{2})
\end{gather*}

With $\phi$ being the rotation angle and $\vec v=(v_{x},v_{y},v_{y})$ being the unit vector of the axis of the rotation[@matrixmathworld][@stanfordhandout1][@stanfordhandout2].

Every frame the rotation matrix is calculated and applied to every vector in the line array. When the line is drawn, if the $z$-axis value of a vector is less than $0$, the point is ignored. That is because the centre of the ball is always at $z=0$ so anything below that is under the ball, and cannot be seen from a top-down view. So, before drawing the line array we filter out the every with $\vec k$ having $z\geq0$.

The label will be tracked with a single point. That point will be on the top of the ball when it's initialised and will be rotated with the same rotation matrix outlined earlier. Additionally, the label will be scaled depending on the orientation of the ball. For example, when the label is facing to the side, the width of the label sprite is squashed to values close to 0. To get the scale factor of this transformation, I will use the formula $SF=rd$, where $r$ is the radius of the ball, and $d$ is the distance of the label to the edge of the ball from the top-down view. One important thing to note is that this is a heuristic method. This technique produces realistic results, but isn't how it exactly works in real life. One method which would produce better results is surfel modeling[@surfel], but implementing something that complex is out of the scope of this project.

Pseudocode:

Initialisation:

```
line_point_array = []
delta_theta = 2*pi/point_num
#point_num is the number of points used for the line
for i in point_num:
   line_point_array.append([cos(i*delta_theta),sin(i*delta_theta),0])
label_point = [0,0,1]
```

Rotation matrix (taken from https://stackoverflow.com/a/6802723):

```
def rotation_matrix(axis, theta):
    axis = axis/pythagorean_distance(axis)
    a = cos(theta/2)
    b, c, d = -axis*sin(theta/2)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return [[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]]
```

Applying the matrix:

```
rotation_angle = ball.speed  / ball_radius
perpendicular_velocity_vector = [-ball.velocity[1], ball.velocity[0], 0]
rotation_matrix = rotation_matrix(perpedicular_velocity_vector, rotation_angle)
for point in line_point_array:
    point = matrix_multiplication(point, rotation_matrix)
label_point = matrix_multiplication(label_point, rotation_matrix)
```

Drawing the stripe:

```
for i in point_num:
    if line_point_array[i][2]>=0 and line_point_array[i+1][2]>=0:
        draw_line(line_point_array[i], line_point_array[i+1])
```

### Object Movement

Most objects which appear in the game will have a velocity vector and a position vector. Every frame the computer will move the objects and then draw the new frame to simulate movement. For example, to simulate ball movement the computer will start drawing the background and the table sides, then add the velocity vector to the position vector of the ball and then draw a new rendering on its updated position.

If the objects don't move too fast and the game is running at moderate frames-per-second, the movement will look smooth.

### Collision Detection

#### Ball-Ball

One way detect a ball-ball collision is to check the distances between ball centres every frame and, if that distance is less than the sum of their radii, that means that they have collided.

![](figures/ball_collision1.png)

Pseudocode:

```
return (pythagorean_distance(ball1.pos-ball2.pos)<=2*ball_radius)
```

#### Ball-Pocket

In the game, any ball which has its centre of mass inside a pocket is considered potted and is instantly removed from the game. Therefore, the algorithm only needs to check if the distance from the centre of the ball to the centre of the pocket is smaller than the radius of the pocket, and if it is, the ball is removed.
Because pockets are modeled as spheres, we use the same algorithm to detect collisions for both balls and pockets.

#### Ball-Line

This collision is called ball-line, because the table walls are modeled as lines. To detect such a collision we need to get the perpendicular distance from the centre of the ball to the line.

![](figures/lineballcollision1.png)

![](figures/lineballcollision2.png)

We know the position of the ball centre, its radius, and 2 points (p1 and p2 on the figure) which define the line. First we find the unit vector of the line (vector from p1 to p2) and the distance vector from one of the points to the ball centre (blue line on the figure). Then we get the distance from p1 to the perpendicular projection point using the _dot product_ on the aforementioned vectors. Note that the result will be a scalar quantity. To get the actual projection point we multiply the scalar value by the unit line displacement vector we got earlier to get the projection point (as labeled on the figure). Then we can get the perpendicular distance from the line to the ball centre by using Pythagorean theorem. We can compare that distance to the balls radius to determine if the ball is colliding with the line.

However, there is one final caveat:

![](figures/lineballcollision3.png)

it's possible for the projected point to be outside of the line. To check that its not the case, we check that the distance from p1 and p2 to the projected point is less than the length of the line (distance from p1 to p2).

Pseudocode:

```
#line[0] is the first point of the line and
#line[1] is the second point of the line
displacement_to_ball = ball.pos - line[0]
displacement_to_second_point = line[1] - line[0]
normalised_point_diff_vector = displacement_to_second_point /
        pythagorean_distance(displacement_to_second_point)
#distance from the first point to the perpendicular point on
#the line
projected_distance = dot_product(normalised_point_diff_vector,
                       displacement_to_ball)
closest_line_point = projected_distance * normalised_point_diff_vector
return (0 <= projected_distance <= pythagorean_distance(displacement_to_second_point)) and
    (pythagorean_distance(closest_line_point - ball.pos + line[0]) <= ball_randius)
```

### Collision resolution

#### Ball-Line

As mentioned in Analysis, when a ball collides with a line the perpendicular component of the balls velocity to the line is reversed and multiplied by $\frac{1+e}{2}$. The component parallel to the line is unchanged. This is because the force from the wall on the ball is applied strictly perpendicularly to the line.


Pseudocode:

```
#line[0] is the first point of the line and
#line[1] is the second point of the line
displacement_to_second_point = line[1] - line[0]
normalised_point_diff_vector = displacement_to_second_point /
                           pythagorean_distance(displacement_to_second_point)
perpendicular_vector = [-normalised_point_diff_vector[1], normalised_point_diff_vector[0]]
#the vector is multiplied by 2 to cancel out the initial velocity
#and then reverse it
ball.velocity = ball.velocity - 2 * dot_product(perpendicular_vector, ball.velocity) *
                perpendicular_vector * (1 + table_coeff_of_restitution) / 2
```

#### Ball-Ball

To resolve a ball-ball collision we need to split the velocities of both balls into 2 perpendicular components. One component is parallel to the vector connecting the centres of the balls and the other one perpendicular to the first component.

![ball collision example](figures/ball_friction1.png)

Just as with the ball-line collision scenario, the component perpendicular to the vector connecting the centres of the balls stays unchanged after the collision while the parallel component needs to be calculated using the inelastic collision formula[@inelasticcollision]:

$$
V'_1=\frac{(1+e)M_1}{M_1+M_2}V_2
$$

Where $e$ is the coefficient of restitution (explained in analysis), $M_1$ and $M_2$ are the masses of the first and second balls, respectively. $V'_1$ is the velocity of the first ball after the collision and $V_2$ is the velocity of the second ball prior to the collision.

In our case, the masses of the balls are all the same, which gives us:
$$
V'_1=\frac{(1+e)}{2}V_2
$$
To summarise, we split the ball velocities into 2 vectors: one vector - $V_a$, which goes through the collision point and the other vector - $V_b$, which is at 90 degrees to the first vector , then the formula for the velocity after the collision is:
$$
V'_1=\frac{(1+e)}{2}V_{a2}+V_{b1}
$$
Pseudocode:

```
point_diff = ball2.pos - ball1.pos
distance = pythagorean_distance(ball1.position, ball2.position)
collision_vector = point_diff / distance
# rotate the vector 90 degrees clockwise to get the perpendicular vector
perpindicular_collision_vector = [collision_vector[1], -collision_vector[0]]
Va1 = dot_product(ball1.velocity, collision_vector)
Vb1 = dot_product(ball2.velocity, collision_vector)
Va2 = dot_product(ball1.velocity, perpindicular_collision_vector)
Vb2 = dot_product(ball2.velocity, perpinducular_collision_vector)
ball1.velocity = Vb1 * collision * (1 + ball_coeff_of_restitution)/2
                + Va2*perpendicular_collision_vector
ball2.velocity = Va1 * collision * (1 + ball_coeff_of_restitution)/2
                + Vb2*perpendicular_collision_vector
```

### Cue

#### Overall cue design

The cue will be modeled as a rectangle with 4 points. The cue will always point at the ball, but it can be rotated around the cue ball. The cue can also be retracted or displaced from the ball. Therefore, the cue object will have to store it's angle to the horizontal and the displacement from the ball.

The user will be able to click and move the cue around. If the cue was retracted when the mouse button was released, the cue will move towards the ball, and then it will exert a force on the ball, causing it to move. The speed with which the cue moves towards the ball will be proportional to the distance it was retracted.

#### Click detection

I will have to make an algorithm, which detects whether a click on the screen is in the cue, from the coordinates of the click. Because the cue is modeled as a rectangle, the problem here can be simplified down to figuring out if a 2d point (the coordinates of the click) is in a rectangle (which is defined with 4 2d points). To do that we find the area of 4 triangles which can be made with 4 rectangle points and the points. We can find the area of triangles using Heron's formula:

$$
A = \sqrt{s(s-a)(s-b)(s-c)}
$$

Where $s$ is the semiperimeter of the triangle:

$$
s = \frac{a+b+c}{2}
$$

![click inside cue](figures/cue1.png)

The area of the green triangles equals the area of the cue, therefore the click is inside the cue.

![click outside cue](figures/cue2.png)

The user clicks on the blue dot which is outside the black cue. The sum of the areas of the green triangles is greater than the area of the cue, thus the point is outside of the cue.

Pseudocode:

```
#rectangle is an array of 2d points which define the cue
#rectangle[0] to rectangle[1] must be the tip of the cue
#for this to work
#point is a 2d point (the coordinates of users click)
inner_lines = [ pythagorean_distance(point, rectangle[0]),
                pythagorean_distance(point, rectangle[1]),
                pythagorean_distance(point, rectangle[2]),
                pythagorean_distance(point, rectangle[3])]
triangle_areas = [  herons(inner_lines[0],inner_lines[1],cue_width)
                    herons(inner_lines[1],inner_lines[2],cue_length),
                    herons(inner_lines[2],inner_lines[3],cue_width),
                    herons(inner_lines[3],inner_lines[0],cue_length)]
rect_area = cue_length * cue_width
return rect_area >= sum(triangle_areas)
```

## Installation

As seen in analysis, GitHub users had problems installing other games like this. I will add instructions for installing the game for Windows and Linux in the README file of the game.

I will also make a simple shell script for Linux which will create a virtual environment and install every dependency through PIP.

## Game Objects and Classes

The code in the project will be split into classes for the ease of testing and readability. Most classes will just encapsulate the methods and the properties related to them, for example, there will be a game state class, which will contain functions which operate on the state of the game, e.g. methods that arrange the balls into their initial triangular position at the start of the game.

There will also be separate classes for every game object in the game. For example, the ball class (figure 13) will be split in 4 different classes - the mathematical part of the ball, which will have things like the position and velocity vector as well as methods which allow to apply a force to the ball. Then there will be 2 types of ball sprites - balls with solid color and balls with a stripe. Finally, there will be a ball sprite class which has an instance of the mathematical ball and one of the sprite classes. I decided to go with the rule of thumb "composition over inheritance" and create instances of those classes in the main sprite class instead of inheriting them. Double inheritance is possible in Python, however it introduces ambiguity and unneeded complexity.

![Ball object classes](figures/object_diagram_ball2.png)

## Input Validation

When a player is allowed change the game state, we must make sure that the player won't abuse anything with these rules:

* When the player is allowed to move the ball, check that the player does not move the ball outside of the game border or into another ball.
* When the player is using the cue, it must not extend indefinitely (there should be a reasonable limit on the extension).
* The players should not be allowed to move the white ball out of the white line region on the first hit.

# Technical solution

Disclaimer: the rotation_matrix function in physics.py was taken from https://stackoverflow.com/a/6802723

To be more productive and avoid code loss situations, I decided to use version control. Specifically git, which is the most popular version control framework [@versioncontrol]. Storing a git repository exclusively on a local machine is dangerous since in case of a disk failure all data is lost. To ensure this never occurs, I regularly uploaded my code to github, which is a cloud service which allows storing git repositories on their server. For complex mathematical operations, I used numpy, a numerical library for python which in addition to a wide range of scalar functions provides a multitude of vector functions. For executing tests I used pytest, a popular python unit-testing library. I also set up a simple continuous integration pipeline which runs all of my tests on a git-push to github. For this I used the Travis CI service. Finally, for managing dependencies I chose pip (all project requirements are specified in requirements.txt), which is a common dependency manager used for python.

## Bugs Fixed During the Development of the Program

### "Reverse" Shot Bug

If the cue is brought very close to the white ball, the game sometimes applied the force in the other direction on the ball, meaning the ball would move towards the ball after the hit.

```
new_velocity = -(self.displacement - config.ball_radius - config.cue_safe_displacement) * \
        config.cue_hit_power * np.array([math.sin(self.angle), math.cos(self.angle)])
```

The game calculated the new velocity of the ball using this formula. `self.displacement` is the displacement of the cue from the centre of the ball, `config.cue_safe_displacement` is the distance from the ball the cue could be displaced and released without affecting the ball. Here is the if statement which check if a ball hit went through.

```
if self.displacement > config.ball_radius:
    self.ball_hit()
```

The if statement was missing the `config.cue_safe_displacement`, therefore if the cue was brought really close to the ball and if the value of `config.cue_safe_displacement` was bigger that zero, `self.displacement - config.ball_radius - config.cue_safe_displacement` could be less than zero and so reverse the direction of the hit.

Code changed (pool/cue.py line 114)[@reverseshotcommit]:

```
-        if self.displacement > config.ball_radius:
+        if self.displacement > config.ball_radius+config.cue_safe_displacement:
            self.ball_hit()
```

This change will insure that `self.displacement - config.ball_radius - config.cue_safe_displacement` will be bigger than zero, thus fixing the bug.

### Collision Resolution Bug

Sometimes, during the play of the game, the balls would "stick" to each other. Turns out there was a problem with the resolution of the collision, or more precisely, when it was triggered.

Collisions are checked for every frame. Figure 18 shows a possible position of the balls 1 frame before the collision and figure 19 shows the same balls in the next frame. The problem is caused by the ball overlap. When the balls collide, there will be some overlap and if the balls are moving quickly, the overlap might be significant.

![one frame before the collision](figures/ball_overlap1.png)

![collision](figures/ball_overlap2.png)

Because the collision is inelastic the balls will lose some kinetic energy, therefore they will be moving slower after collision (as shown on figure 20).

![one frame after the collision](figures/ball_overlap3.png)

After colliding and moving once (one frame) they balls can still be inside each other, and thus the collision detection algorithm will trigger in the next frame again. If collision resolution algorithm is called on balls which are moving in opposite directions, the vectors will be reversed, and on the next frame the balls will be moving towards each other, making the process repeat indefinitely, which in turn makes the balls stick.

![vectors with dot product](figures/ball_collision3.png)

To resolve the collision properly we will take the dot product of the difference between the centres of 2 balls (labeled _distance diff_ on figure 21) and the velocity difference vector (labeled as _v1-v2_). If the result is positive that means that the balls are moving towards each other and we can collide them, otherwise we ignore them.

__Code changed__:

Added the dot product check in function *collide_balls*[@ballcollisioncommit]:

```
+def collide_balls(ball1, ball2):
+    point_diff = ball2.pos-ball1.pos
+    system_velocity = ball1.velocity-ball2.velocity
...
+    if np.dot(point_diff,system_velocity)>0:
..
```

Later reworked into:

```
def ball_collision_check(ball1, ball2):
    # distance check followed by checking if either of the balls are moving
    # followed by vector projection check, to see if both are moving towards
    # each other
    return distance_less_equal(ball1.pos, ball2.pos, 2 * config.ball_radius) and \
        np.count_nonzero(np.concatenate((ball1.velocity, ball2.velocity))) > 0 and \
        np.dot(ball2.pos - ball1.pos, ball1.velocity - ball2.velocity) > 0
```

## main.py

```{r engine='bash', comment='', echo=F}
cat pool/main.py
```

## gamestate.py

```{r engine='bash', comment='', echo=F}
cat pool/gamestate.py
```

## physics.py

```{r engine='bash', comment='', echo=F}
cat pool/physics.py
```

## collisions.py

```{r engine='bash', comment='', echo=F}
cat pool/collisions.py
```

## ball.py

```{r engine='bash', comment='', echo=F}
cat pool/ball.py
```

## cue.py

```{r engine='bash', comment='', echo=F}
cat pool/cue.py
```

## graphics.py

```{r engine='bash', comment='', echo=F}
cat pool/graphics.py
```

## table_sprites.py

```{r engine='bash', comment='', echo=F}
cat pool/table_sprites.py
```

## event.py

```{r engine='bash', comment='', echo=F}
cat pool/event.py
```

## config.py

```{r engine='bash', comment='', echo=F}
cat pool/config.py
```

# Testing

## Unit Testing
In my game there are two main things to test - the process of the physical simulation, meaning the mathematics behind the collisions, collision detection and others, and the user interface. To test the mathematics, I've made a set of tests in a form of a script, which, when executed, runs the main program with the test input data. These tests are considered white box testing, more specifically, unit testing, because I am testing specific functions of the program.
To make the job of testing the game with every change easier, I have made unit tests which are executed on my code every time I make a commit to GitHub. The unit tests are included with the game in the folder “tests”, the tests contain some input, which is used with the functions of the game which are responsible for a specific task. Lets look at a particular example:

```
def test_point_distance1(self):
    assert physics.point_distance(np.array([0, 0]), np.array([3, 4])) == 5
```

This function tests the function responsible for calculating the distance between two points. The function uses the function to calculate the distance between points (0,0) and (3,4), and compares it to 5. If the function does not return 5, the test returns an exception.
Here is another, more complicated example of an edge case test:

```
def test_movement4(self):
    ball1.set_velocity((1, 1))
    ball2.move_to(-fortyfive_degree_position)
    ball2.set_velocity((1, 1))
    assert not physics.ball_collision_check(ball1, ball2)
```

![test 1](figures/test1.png)

The test sets the balls such that they are touching, however, both balls are moving with the same velocity. That means there is no collision.

This is an example of an extreme test:

```
def test_movement10(self):
    ball1.set_velocity((0, 1))
    ball2.move_to((0, ball_radius * 2))
    ball2.set_velocity((200000000, -200000000000))
    assert physics.ball_collision_check(ball1, ball2)
```

The values in the test are exaggerated so that we know that the game can handle extreme values.

![test2](figures/test2.png)

For executing tests I used PyTest, a popular python unit-testing library. I set up a simple continuous integration pipeline which runs all of my tests on a git-push to GitHub. For this I used the Travis CI service.

### How To Run the Tests

The file contains many tests, including matrix transformation, line to ball collision and the triangle area tests. Here are the test files:

#### test_ball_line_collision.py
```{r engine='bash', comment='', echo=F}
cat tests/test_ball_line_collision.py
```

#### test_ball_ball_collision.py
```{r engine='bash', comment='', echo=F}
cat tests/test_ball_ball_collision.py
```

#### test_distance.py
```{r engine='bash', comment='', echo=F}
cat tests/test_distance.py
```

#### test_rotation_matrix.py
```{r engine='bash', comment='', echo=F}
cat tests/test_rotation_matrix.py
```

#### test_triangle_area.py
```{r engine='bash', comment='', echo=F}
cat tests/test_triangle_area.py
```

Here is me running the tests on my machine on the latest pool build.

```
PYTHONPATH=./pool py.test --cov=.
========================= test session starts ==========================
platform linux -- Python 3.6.4, pytest-3.2.3, py-1.5.2, pluggy-0.4.0
rootdir: /home/max/code/python/pool, inifile:
plugins: cov-2.5.1, asyncio-0.8.0
collected 31 items

tests/test_physics.py ...............................

----------- coverage: platform linux, python 3.6.4-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
pool/__init__.py            0      0   100%
pool/ball.py              120     84    30%
pool/collisions.py         26     18    31%
pool/config.py             61      5    92%
pool/cue.py               100     80    20%
pool/event.py              18     12    33%
pool/gamestate.py         210    170    19%
pool/graphics.py           49     38    22%
pool/main.py               31     31     0%
pool/physics.py            44      7    84%
pool/table_sprites.py      77     56    27%
-------------------------------------------
TOTAL                     736    501    32%


====================== 31 passed in 0.39 seconds =======================
```

Tests for other builds and instructions on how to run the tests yourself can be found on the GitHub repository page^[https://github.com/max-kov/pool]. The records of how the build passes the tests are available on GitHub^[https://github.com/max-kov/pool/commits/master] or on Travis-ci^[https://travis-ci.org/max-kov/pool/builds].



## Conventional Tests

Normally, in this section candidates test their projects and add the proof in the form of screenshots. With my project, however, it is hard to understand what is going on in the game only through screenshots, so I recorded a gameplay video, doing every test outlined in this section.
These test will be done by me playing the game:

### GUI

```{r echo = FALSE, results = 'asis'}
library(knitr)
library(kableExtra)
library(pander)
options(knitr.kable.NA = '')
pander(read.table("tables/gui.csv", header=TRUE, sep=","))
```

#### Test number 1

Figure 20 and 21 show that the button correctly changes the color of the text upon hovering.

![The menu before hovering over the button](testing/menu1.png)

![The menu while hovering over the button](testing/menu2.png)

#### Tests number 2


### Collisions

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/collisions.csv", header=TRUE, sep=","))
```

#### Test number 1

Figures 25 to 28 show several moments of a successful shot on the teal ball, where it is potted. As soon as the teal ball reaches the pocket, it is removed, as it is meant to do.

#### Test number 2

Figures 22 to 24 show the initial break.

I have tested the mathematics of the collisions using unit tests before, but this serves as additional proof that the collisions work.

![Ball break 1/3](testing/break1.png)

![Ball break 2/3](testing/break2.png)

![Ball break 3/3](testing/break3.png)

![Potting the teal ball 1/4](testing/pot1.png)

![Potting the teal ball 2/4](testing/pot2.png)

![Potting the teal ball 3/4](testing/pot3.png)

![Potting the teal ball 4/4](testing/pot4.png)

* The ball cannot be moved outside of the table, or into other balls, when it can be moved

### Game Rules

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/gui.csv", header=TRUE, sep=","))
```

* The game ends if you pot the 8ball illegally, and the player who potted the ball loses the game
* The game ends if you pot the 8ball legally, and the player who potted the ball wins the game
* If the player pots a ball of a color, and the groups are not assigned yet, the player who potted the ball is assigned to that group

# Evaluation

## Objective Analysis

Here are the objectives set for this project:

* The rules of pool should be implemented in the game
* The game should run at more than 30 frames per second
* Physical interactions in the game should be realistic:
  * The movement of the balls should be affected by friction
  * The ball collisions should be inelastic
  * The game should detect and resolve ball-ball and ball-table side collisions
* Game animations look realistic:
  * The balls should visibly rotate when moving
  * The cue should move towards the ball when a player is hitting a ball
* A configuration file, which can change some of the in-game options like ball size or cue hit power
* An installation guide/README file for users

Collisions, ball movement and game rules were completed and tested in Testing section.

The game frame per second limit was set to 60 fps, and judging from looks, it runs at steady 60 frames per second without visible tearing. The frame per second limit variable can be changed in the configuration file.

Talking about the configuration file, the configuration options are perhaps too extensive and contain stuff you wouldn't expect, for example, you could change the position of the individual pockets in the file. Even though the file is written in python, users won't need to know python to change these settings, because the file looks like a normal text file. This mostly because of pythons high level syntax which is very close to pseudocode.

As mentioned before, the installation guide for Linux and Windows users is included in the README file. Because python has to install the required modules before the game could be played, the installation for windows users requires the command line. For Linux, however, there is a simple shell script which creates a virtual environment, installs the required modules, and starts the game.


## User Feedback

The game became surprisingly popular, gaining traffic on GitHub and, at the time of writing this, becoming the first search result on Google for "python pool game", which is, admittedly, a very specific search query.

## Possible Extensions

As mentioned in analysis the multiplayer feature for this game is something I would like to implement, but it would to complex for me, because it requires a server to overlook the players actions and to synchronise both player's programs. One similar feature I would like to implement, but lack the resources to do so is an AI player. While it is significantly easier to implement AI than multiplayer, but after looking into this problem I have not found an easy way to do this. One algorithm for AI which caught my attention was this:

1. Find every possible ball on the table you can hit.
2. Check if any of the balls have a direct unblocked path to a pocket.
3. Calculate where the point of contact must be made to hit the ball into that pocket.
4. Calculate the angle of the cue required so that the cue ball would hit the target ball at the correct point of contact.

This is a fairly simple algorithm but there are several problems with it. Firstly, it's not trivial to find the list of balls you can hit, without hitting another ball. One way to do that is - whenever you are checking a particular ball, see if any other balls are in the sector between the cue ball and the ball. That is at least $\mathcal{O}(n^2)$. Same for checking if the ball has an unblocked path to the pocket. Another way to implement this would be machine learning algorithms, but these are famous for requiring high level mathematics knowledge which I lack.

Another design choice which could be improved is the stripe rendering algorithm. The problem with the algorithm is that it is an approximation and can be wrong when looked into very carefully.

![A picture of a rotated ball in-game](figures/ball_screen1.png)

![A picture of balls in-game](figures/ball_screen2.png)

In real life the stripe on the top of the ball would look a bit thicker than on the sides, but it is of constant width in-game. This is because the stripe on the top is slightly closer to the observer and thus takes up a bigger section of their vision. To generate the stripe properly, we would have to consider the change of distance when the ball is rolling.

There also could be cosmetic additions like sounds or custom skins for the balls.


# References
