---
title: Computer Science project.
author: Maksims Kovalovs
header-includes:
- \usepackage{epstopdf}
- \usepackage{fancyhdr}
- \usepackage{graphicx}
- \usepackage{lipsum}
- \graphicspath{ {figures/}{testing/} }
- \pagestyle{fancy}
- \fancyhead[CO,CE]{Maksims Kovalovs -insert candidate num here-}
- \fancyfoot[CO,CE]{Chilwell School 28210}
- \fancyfoot[LE,RO]{\thepage}
output:
    html_document:
        theme: journal
        toc: true
        toc_float: true
        toc_depth: 2
bibliography: references.bib
link-citations: yes
csl: refstyle.csl
---


```{r echo = FALSE, results = 'asis'}
library(knitr)
library(kableExtra)
library(pander)
options(knitr.kable.NA = '')
```

# Analysis

## Introduction

Even though the video game industry didn't exist 4 decades ago, video games now are one of the most popular hobbies of youth. With new variations on the idea like mobile and virtual reality games, it is likely that these games are here to stay for a long time.

This project is about making an 8 ball pool game with a top down view that can be played by 2 players on the same computer. The main problem this project will have to solve is the rendering of game objects, e.g. rolling balls, and the physical interactions between these objects, e.g. ball collisions.

## Existing Solutions

Most pool games online are hosted online game websites like www.miniclip.com. At the time of writing this, the 8 ball pool game is the top game on the website and google says that the game was reviewed 1,563,388 times (Figure 1). This shows that there is a market for these types of games. The problem is, online websites don't provide the source code for their games which means that the users cannot learn about how the physics of the game work, but also the users won't be able to customize the game options like ball size or color.

\begin{figure}[tph!]
\centerline{\includegraphics[totalheight=6cm]{miniclip_reviews.png}}
\caption{First result when searching for "pool game" in Google}
\end{figure}

I've looked on GitHub for pool games and there were some projects like mine, but most of the projects  were abandoned or unfinished[@githubpool1]. For example, the user raysmith619 has a similar repository. In his README file he says that the game is missing the pockets, friction and ball rotation animations. I see these things as very important to the game and will implement them.

There is a big pool game project written in Ruby on Rails[@githubpool2]. The project is finished however, there are different problems with this project. Looking at the issues page (Figure 2) of the projects, some users are having problems installing the software[@githubissue].

Additionally, looking at commit messages (Figure 3), you can see that the main maintainer was trying, albeit unsuccessfully, to add advertisements to the game[@githubads] and online pool games are often monetized with advertisements in the website page. My game will not contain any sort of advertisement because I believe that they will take away from the user experience.

![People having problems installing the pool game (GitHub issue)](figures/installation_problems.png)

![GitHub commit message](figures/ads.png)

To summarise, my game should have parts the mentioned games don't have - pockets, friction and ball rotation animations. The game should come with an instruction of how to install the game, so that users could acquire the game easily. Also, there should be a configuration file, so that some properties of the game objects could be changed, e.g. ball size or ball colour.

## Evidence of Analysis

To get more insight to the problem I had to solve and understand which features I had to implement. I decided to interview one of my sixth form classmates about it:

__What are the problems with the current system?__

_We were supposed to have a pool table installed in the common room this year, but the student union didn't have enough money to do that. Our group has a lot of free time in school, and we really want to play pool against each other, even if it's on a computer._

__Have you found anything online which works as you want?__

_We have found some pool games online, but most of them are player vs AI and require internet connection, which, unfortunately, you can't take for granted. In our case we don't really need to be able to play via the internet, an offline game should be fine._

__Is there anything specific you want in the game?__

_A normal pool game with rules for 2 players should suffice. It shouldn't be too slow or lag. Obviously, the balls and their movement should look like in real life. It would be interesting to have a level editor or something which allows the user to tweak the game options like the initial position of the balls._

The user asked for standard features for this type of game, except for the level editor. That can be achieved in different ways, like an in-game editor GUI or a configuration file, which is present in many new games.

## Identification of End Users

The main end users of this project are my school friends who are interested in playing a computer version of pool. The code will include the physical formulas of collisions and friction, and because this project will open-source and available online, this game might help other people to understand how 2-dimensional ball physics work.

## Proposed Solution

The aim of the project is to build a pool game. Looking at other games online, it would be wise to add a main menu, however the game doesn't have any features that would complement the main menu, e.g. multiplayer, so the main menu could be minimal and small. The main menu might be useful if I decide to add an options menu or something else which requires a separate screen. The user interface will also include in-game state trackers, for example, there will be a current player label, which indicates which player's turn it is. The collisions and friction will have physical models (outlined later in this section). The game will be played on a single computer, with players taking turns to make their move.  Finally, the user interview revealed a need for some sort of configuration option in the game. I think the best way to achieve that would be a configuration file, which is a text file with all of the constants in it. That way, if the user wants to change the color of a particular ball, they would be able to do it by changing a variable in the configuration file. This method is easy to implement and provides the highest level of customization possible.

This project will deal with 3d rendering, physical simulation and game development areas of computer science. Therefore, I researched some of the relevant techniques game developers use to create games.

### Collisions

To simulate ball collisions, every frame the game will check for these collisions by comparing the distances between ball centres, and if it detects any, it will resolve the collision based on the velocity and the position of the balls using linear algebra and vector operations. To model ball-ball and ball-table side collisions I can use the inelastic collision formula[@inelasticcollision]. The formula depends on the coefficient of restitution - $e$, whose values range from 0 to 1 (1 being a perfectly elastic collision and 0 perfectly inelastic). Low values of $e$ mean that there is a lot of kinetic energy lost in collision and visa versa.

### Rendering
Some parts of the balls (like the white stripe around the balls) can be modeled as 3d objects and rotated using rotation matrices when the ball is moving and then projected on the table (into a 2d space). Matrices are rectangular arrays which enable us to do spacial transformations of objects. Here is an example of a matrix:

$$
\begin{bmatrix}
    1 & 2 & 0 \\
    2 & 8 & 2 \\
\end{bmatrix}
$$

Matrices are very useful when you want to manipulate vectors in space. For example, this matrix:

$$
\begin{bmatrix}
    cos(\theta) & -sin(\theta) \\
    sin(\theta) & cos(\theta) \\
\end{bmatrix}
$$

rotates points about the origin through an angle $\theta$ counterclockwise. To rotate a vector by the matrix, you must do matrix multiplication. If you have 2 matrices $A$ and $B$, the matrix multiple $C$ is defined like this:

$$
A=
\begin{bmatrix}
    a_{11}&a_{12}&\cdots &a_{1m}\\
    a_{21}&a_{22}&\cdots &a_{2m}\\
    \vdots &\vdots &\ddots &\vdots \\
    a_{n1}&a_{n2}&\cdots &a_{nm}\\
\end{bmatrix}
,B=
\begin{bmatrix}
    b_{11}&b_{12}&\cdots &b_{1p}\\
    b_{21}&b_{22}&\cdots &b_{2p}\\
    \vdots &\vdots &\ddots &\vdots \\
    b_{m1}&b_{m2}&\cdots &b_{mp}\\
\end{bmatrix}
$$
$$
AB=
\begin{bmatrix}
    c_{11}&c_{12}&\cdots &c_{1p}\\
    c_{21}&c_{22}&\cdots &c_{2p}\\
    \vdots &\vdots &\ddots &\vdots \\
    c_{n1}&c_{n2}&\cdots &c_{np}\\
\end{bmatrix}
$$
Or
$$
c_{ij}=a_{i1}b_{1j}+\cdots +a_{im}b_{mj}=\sum_{k=1}^{m}a_{ik}b_{kj}
$$
So, for example, if you have a point in 2-dimensional space $\vec k=(1,2)$ which you want to rotate 90 degrees counterclockwise, you compute:

$$
\begin{bmatrix}
    cos(90) & -sin(90) \\
    sin(90) & cos(90) \\
\end{bmatrix}
\begin{bmatrix}
    1 \\
    2 \\
\end{bmatrix}
=
\begin{bmatrix}
    -2 \\
    1 \\
\end{bmatrix}
$$

You can see the rotation represented on a 2d plane on Figure 3.

![Rotation in 2d plane](figures/rotation.png)

### Friction
To model rolling friction I can use the formula $F=C_{rr}N$ where $C_{rr}$ is the coefficient of rolling resistance of the balls[@rollingfriction]. That means the balls will have a constant frictional force on them (when they are moving).

### Language Choice
At the beginning of the project, I was experienced in two programming languages - Python and Pascal. To pick one, I had to do some research on their suitability for the job.

The programming language of my choice should be able to deal with matrix manipulations outlined earlier. Both languages support array data structures, however, Python has a numerical computations library - Numpy[@numpy]. This library has implemented functions for matrix operations, like matrix multiplication and more.

According to the Tiobe Index[@tiobe] and PYPL[@pypl], Python is significantly more popular than Pascal and hence is a better language to use due to more resources available online (e.g. more StackOverlow questions/answers). This also suggests that python will have higher quality/variety of libraries due to a larger community. Additionally, Python is a duck-typed language, which means no explicit type declarations are required. This makes Python less verbose and more flexible, allowing for faster development, which is beneficial given a limited amount of time for development.

Finally, a game development library will be at the core of my project so it is important to pick a language with a mature, well maintained game development framework. A number of resources list the most popular libraries used for implementing games in Pascal[@fpcgameengine][@delphigamedev]. All of these libraries are either missing completely (home page is broken), seriously outdated or are very immature. At the same time, Python has Pygame[@pygamegithub] which is open source, actively maintained (at the time of writing last commit 3 days ago) and mature (3k commits with 40 contributors).

## Objectives

* The rules of pool should be implemented in the game
* The game should run at more than 30 frames per second
* Physical interactions in the game should be realistic:
  * The movement of the balls should be affected by friction
  * The ball collisions should be inelastic
  * The game should detect and resolve ball-ball and ball-table side collisions correctly
* Game animations should look realistic:
  * The balls should visibly rotate when moving
  * The cue should move towards the ball when a player is hitting a ball
* A configuration file, which can change some of the in-game options like ball size or cue hit power
* An installation guide/README file for users

## Acceptable Limitations

The fact that the balls have be modeled as 3d objects makes the rendering problem challenging. The balls can be rendered using different techniques. So, as a result, I might use simplified rendering algorithms, which look acceptable, but not perfect. For example, the rendering algorithm will not render reflections on the balls surface, because that would be too complicated to implement without a game engine and would not add much to the user's experience. On the contrary, features like the reflective ball surfaces may make the gameplay experience worse by using a lot of computer resources and thus slowing down the game.

# Documented Design

## User Interface

A good pool game should implement the following features:

* The game screen should be big enough to see everything clearly.
* The balls should look realistic, and have easily distinguishable stripes on them so the players would not be confused which balls they need to pot.
* The game should have aiming lines to help the player aim. These lines are needed because in real life the player can line up the ball and see where it will go, so the game should have similar functionality.
* The game should have a minimal game menu with a button to start the game and leave the game.

![main menu model](figures/main_menu.png)

In-game interface will consist of the cue, which can be aimed and retracted back to make a shot. The game will also have some indicators of the state of the game:

* A "current player" indicator, which can just be a label on the top
* An indicator of which group of balls the players need to pot to win the game
* An indicator of whether the current player can move the cue ball

![in-game GUI sketch](figures/ui_example1.png)

### Modular Design

* Main menu
  * The game
    * Stop the game
    * Game over
  * Quit the game

### Controls

* The user will use the mouse to move the cue or the cue ball (if it is movable).
* In the menu the main input method is the mouse, however the user should be able to quit the game by pressing ESC key.
* While in game, the user should be able to press the ESC button to leave to the main menu.

### Pool Rules
To implement the rules of pool I went online and read about the game rules[@poolrules], here are the main points:

* The first break should be performed behind the white line on the table, and the ball may be placed anywhere behind that line.
* If the players haven't decided which group of balls they are on, and the player pots a ball or several balls of a particular group, that player now is on that group.
* To win the game, you must pot the 8 ball legally.
* You must first sink every ball from the group you are on, to pot the 8 ball.
* Failure to hit a ball from your group on your first ball hit, or not hitting a ball at all on your turn, gives your opponent a hit from his hand (which means that he is allowed to put the white ball anywhere on the table)
* If you pot the 8 ball illegally, you lose the game.


## Algorithms

### The main game loop

Pseudocode:

```
while True:
    while not game_is_over():
        resolve_collisions()
        move_everything()
        redraw_everything()

        if all_balls_stopped():
            apply_pool_rules()
            wait_for_cue_hit()
```

This is the whole game split into functions. Every turn, one player uses the cue, then while the balls are moving, the game will check for any collisions, resolve them and do one frame, meaning it will move every moving object and redraw everything. The main game loop will continue doing that until the game is over or the game is closed.

![game flow](figures/game_flowchart.png)

### Rendering

The ball can be split in 3 parts which must be rendered separately:

* The ball stripe
* The label (circle with the number)
* The solid color body

![Initial position of the ball](figures/ball1.png)

![A rotated position of the ball](figures/ball2.png)

A sphere of a solid color will look like a circle from any angle in 2-dimensions. That's why we don't need to worry about any rotations of the solid sphere component. Hence we can just draw the solid body as a solid circle and draw everything else on top.

The stripe on the ball will be modelled as a sequence of connected lines, forming a circle. The lines will be represented with an array of vectors $a$ marking the start/end points of the lines.
$$
a=
\begin{bmatrix}
    \vec k_{1}, & \vec k_{2}, & \vec k_{3}, & \dots, & \vec k_{n}
\end{bmatrix}
$$

Where $\vec k_n$ is a 3d vector on the surface of the ball. We will draw lines from $\vec k_1$ to $\vec k_2$, from $\vec k_2$ to $\vec k_3$ and so on for every adjacent pair of points (a line from $\vec k_{i-1}$ to $\vec k_{i}$ for $i\in[2,n]$). This will draw a polygon that very closely follows the shape of the stripe.

When a ball rotates, the points representing the ball's stripe are transformed accordingly by multiplying them with a rotation matrix. A 3d rotation matrix can be calculated from a rotation axis and an angle through which the ball needs to be rotated. We know the axis of rotation - it is the line perpendicular to the velocity vector and parallel to the table surface, and the angle of rotation is calculated using the formula
$$
\theta=\frac{vt}{r}
$$
where $v$ is the linear speed of the ball and $r$ is the radius of the ball with $\theta$ being in radians. The intuition for the formula is that when the ball is moving, every point on the circumference must touch the ground before it does a full rotation, therefore it must move $2\pi r$ units for a full rotation. The angle the ball has rotated is therefore given by $\theta = \frac{S}{r}$, where $S$ is the linear distance the ball has traveled. Then we substitute the formula $S=vt$ to get the aforementioned formula.

The rotation matrices are calculated using the Euler–Rodrigues formula. The rotated vector $\vec k\prime$ is calculated according to this formula:
$$
\vec k\prime =
\begin{bmatrix}
    a^2+b^2-c^2-d^2 & 2(bc-ad) & 2(bd+ac) \\
    2(bc+ad) & a^2+b^2-c^2-d^2 & 2(cd-ab) \\
    2(bd-ac) & 2(cd+ab) & a^2+b^2-c^2-d^2
\end{bmatrix}
\vec k
$$

Where $a,b,c,d$ are

\begin{gather*}
a = cos(\frac{\phi}{2}) \\
b = v_{x}sin(\frac{\phi}{2}) \\
c = v_{y}sin(\frac{\phi}{2}) \\
d = v_{z}sin(\frac{\phi}{2})
\end{gather*}

With $\phi$ being the rotation angle and $\vec v=(v_{x},v_{y},v_{y})$ being the unit vector of the axis of the rotation[@matrixmathworld][@stanfordhandout1][@stanfordhandout2].

Every frame the rotation matrix is calculated and applied to every vector in the line array. When the line is drawn, if the $z$-axis value of a vector is less than $0$, the point is ignored. That is because the centre of the ball is always at $z=0$ so anything below that is under the ball, and cannot be seen from a top-down view. So, before drawing the line array we filter out the every with $\vec k$ having $z\geq0$.

The label will be tracked with a single point. That point will be on the top of the ball when it's initialised and will be rotated with the same rotation matrix outlined earlier. Additionally, the label will be scaled depending on the orientation of the ball. For example, when the label is facing to the side, the width of the label sprite is squashed to values close to 0. To get the scale factor of this transformation, I will use the formula $SF=rd$, where $r$ is the radius of the ball, and $d$ is the distance of the label to the edge of the ball from the top-down view. One important thing to note is that this is a heuristic method. This technique produces realistic results, but isn't how it exactly works in real life. One method which would produce better results is surfel modeling[@surfel], but implementing something that complex is out of the scope of this project.

Pseudocode:

Initialisation:

```
line_point_array = []
delta_theta = 2*pi/point_num
#point_num is the number of points used for the line
for i in point_num:
   line_point_array.append([cos(i*delta_theta),sin(i*delta_theta),0])
label_point = [0,0,1]
```

Rotation matrix (taken from https://stackoverflow.com/a/6802723):

```
def rotation_matrix(axis, theta):
    axis = axis/pythagorean_distance(axis)
    a = cos(theta/2)
    b, c, d = -axis*sin(theta/2)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return [[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]]
```

Applying the matrix:

```
rotation_angle = ball.speed  / ball_radius
perpendicular_velocity_vector = [-ball.velocity[1], ball.velocity[0], 0]
rotation_matrix = rotation_matrix(perpedicular_velocity_vector, rotation_angle)
for point in line_point_array:
    point = matrix_multiplication(point, rotation_matrix)
label_point = matrix_multiplication(label_point, rotation_matrix)
```

Drawing the stripe:

```
for i in point_num:
    if line_point_array[i][2]>=0 and line_point_array[i+1][2]>=0:
        draw_line(line_point_array[i], line_point_array[i+1])
```

### Object Movement

Most objects which appear in the game will have a velocity vector and a position vector. Every frame the computer will move the objects and then draw the new frame to simulate movement. For example, to simulate ball movement the computer will start drawing the background and the table sides, then add the velocity vector to the position vector of the ball and then draw a new rendering on its updated position.

If the objects don't move too fast and the game is running at moderate frames-per-second, the movement will look smooth.

### Collision Detection

#### Ball-Ball

One way detect a ball-ball collision is to check the distances between ball centres every frame and, if that distance is less than the sum of their radii, that means that they have collided.

![](figures/ball_collision1.png)

Pseudocode:

```
return (pythagorean_distance(ball1.pos-ball2.pos)<=2*ball_radius)
```

#### Ball-Pocket

In the game, any ball which has its centre of mass inside a pocket is considered potted and is instantly removed from the game. Therefore, the algorithm only needs to check if the distance from the centre of the ball to the centre of the pocket is smaller than the radius of the pocket, and if it is, the ball is removed.
Because pockets are modeled as spheres, we use the same algorithm to detect collisions for both balls and pockets.

#### Ball-Line

This collision is called ball-line, because the table walls are modeled as lines. To detect such a collision we need to get the perpendicular distance from the centre of the ball to the line.

![](figures/lineballcollision1.png)

![](figures/lineballcollision2.png)

We know the position of the ball centre, its radius, and 2 points (p1 and p2 on the figure) which define the line. First we find the unit vector of the line (vector from p1 to p2) and the distance vector from one of the points to the ball centre (blue line on the figure). Then we get the distance from p1 to the perpendicular projection point using the _dot product_ on the aforementioned vectors. Note that the result will be a scalar quantity. To get the actual projection point we multiply the scalar value by the unit line displacement vector we got earlier to get the projection point (as labeled on the figure). Then we can get the perpendicular distance from the line to the ball centre by using Pythagorean theorem. We can compare that distance to the balls radius to determine if the ball is colliding with the line.

However, there is one final caveat:

![](figures/lineballcollision3.png)

it's possible for the projected point to be outside of the line. To check that its not the case, we check that the distance from p1 and p2 to the projected point is less than the length of the line (distance from p1 to p2).

Pseudocode:

```
#line[0] is the first point of the line and
#line[1] is the second point of the line
displacement_to_ball = ball.pos - line[0]
displacement_to_second_point = line[1] - line[0]
normalised_point_diff_vector = displacement_to_second_point /
        pythagorean_distance(displacement_to_second_point)
#distance from the first point to the perpendicular point on
#the line
projected_distance = dot_product(normalised_point_diff_vector,
                       displacement_to_ball)
closest_line_point = projected_distance * normalised_point_diff_vector
return (0 <= projected_distance <= pythagorean_distance(displacement_to_second_point)) and
    (pythagorean_distance(closest_line_point - ball.pos + line[0]) <= ball_randius)
```

### Collision resolution

#### Ball-Line

As mentioned in Analysis, when a ball collides with a line the perpendicular component of the balls velocity to the line is reversed and multiplied by $\frac{1+e}{2}$. The component parallel to the line is unchanged. This is because the force from the wall on the ball is applied strictly perpendicularly to the line.


Pseudocode:

```
#line[0] is the first point of the line and
#line[1] is the second point of the line
displacement_to_second_point = line[1] - line[0]
normalised_point_diff_vector = displacement_to_second_point /
                           pythagorean_distance(displacement_to_second_point)
perpendicular_vector = [-normalised_point_diff_vector[1], normalised_point_diff_vector[0]]
#the vector is multiplied by 2 to cancel out the initial velocity
#and then reverse it
ball.velocity = ball.velocity - 2 * dot_product(perpendicular_vector, ball.velocity) *
                perpendicular_vector * (1 + table_coeff_of_restitution) / 2
```

#### Ball-Ball

To resolve a ball-ball collision we need to split the velocities of both balls into 2 perpendicular components. One component is parallel to the vector connecting the centres of the balls and the other one perpendicular to the first component.

![ball collision example](figures/ball_friction1.png)

Just as with the ball-line collision scenario, the component perpendicular to the vector connecting the centres of the balls stays unchanged after the collision while the parallel component needs to be calculated using the inelastic collision formula[@inelasticcollision]:

$$
V'_1=\frac{(1+e)M_1}{M_1+M_2}V_2
$$

Where $e$ is the coefficient of restitution (explained in analysis), $M_1$ and $M_2$ are the masses of the first and second balls, respectively. $V'_1$ is the velocity of the first ball after the collision and $V_2$ is the velocity of the second ball prior to the collision.

In our case, the masses of the balls are all the same, which gives us:
$$
V'_1=\frac{(1+e)}{2}V_2
$$
To summarise, we split the ball velocities into 2 vectors: one vector - $V_a$, which goes through the collision point and the other vector - $V_b$, which is at 90 degrees to the first vector , then the formula for the velocity after the collision is:
$$
V'_1=\frac{(1+e)}{2}V_{a2}+V_{b1}
$$
Pseudocode:

```
point_diff = ball2.pos - ball1.pos
distance = pythagorean_distance(ball1.position, ball2.position)
collision_vector = point_diff / distance
# rotate the vector 90 degrees clockwise to get the perpendicular vector
perpindicular_collision_vector = [collision_vector[1], -collision_vector[0]]
Va1 = dot_product(ball1.velocity, collision_vector)
Vb1 = dot_product(ball2.velocity, collision_vector)
Va2 = dot_product(ball1.velocity, perpindicular_collision_vector)
Vb2 = dot_product(ball2.velocity, perpinducular_collision_vector)
ball1.velocity = Vb1 * collision * (1 + ball_coeff_of_restitution)/2
                + Va2*perpendicular_collision_vector
ball2.velocity = Va1 * collision * (1 + ball_coeff_of_restitution)/2
                + Vb2*perpendicular_collision_vector
```

### Cue

#### Overall cue design

The cue will be modeled as a rectangle with 4 points. The cue will always point at the ball, but it can be rotated around the cue ball. The cue can also be retracted or displaced from the ball. Therefore, the cue object will have to store it's angle to the horizontal and the displacement from the ball.

The user will be able to click and move the cue around. If the cue was retracted when the mouse button was released, the cue will move towards the ball, and then it will exert a force on the ball, causing it to move. The speed with which the cue moves towards the ball will be proportional to the distance it was retracted.

#### Click detection

I will have to make an algorithm, which detects whether a click on the screen is in the cue, from the coordinates of the click. Because the cue is modeled as a rectangle, the problem here can be simplified down to figuring out if a 2d point (the coordinates of the click) is in a rectangle (which is defined with 4 2d points). To do that we find the area of 4 triangles which can be made with 4 rectangle points and the points. We can find the area of triangles using Heron's formula:

$$
A = \sqrt{s(s-a)(s-b)(s-c)}
$$

Where $s$ is the semiperimeter of the triangle:

$$
s = \frac{a+b+c}{2}
$$

![click inside cue](figures/cue1.png)

The area of the green triangles equals the area of the cue, therefore the click is inside the cue.

![click outside cue](figures/cue2.png)

The user clicks on the blue dot which is outside the black cue. The sum of the areas of the green triangles is greater than the area of the cue, thus the point is outside of the cue.

Pseudocode:

```
#rectangle is an array of 2d points which define the cue
#rectangle[0] to rectangle[1] must be the tip of the cue
#for this to work
#point is a 2d point (the coordinates of users click)
inner_lines = [ pythagorean_distance(point, rectangle[0]),
                pythagorean_distance(point, rectangle[1]),
                pythagorean_distance(point, rectangle[2]),
                pythagorean_distance(point, rectangle[3])]
triangle_areas = [  herons(inner_lines[0],inner_lines[1],cue_width)
                    herons(inner_lines[1],inner_lines[2],cue_length),
                    herons(inner_lines[2],inner_lines[3],cue_width),
                    herons(inner_lines[3],inner_lines[0],cue_length)]
rect_area = cue_length * cue_width
return rect_area >= sum(triangle_areas)
```

## Installation

As seen in analysis, GitHub users had problems installing other games like this. I will add instructions for installing the game for Windows and Linux in the README file of the game.

I will also make a simple shell script for Linux which will create a virtual environment and install every dependency through PIP. The script will create a virtual environment using the venv module and install the necessary python modules in the game folder. The virtual environment is needed so that the needed python libraries would not be installed system-wide, which means that when the user deletes the game folder, the installed libraries will be deleted too, not leaving unnecessary libraries on the user's computer. Additionally, this will prevent some bugs due to different version of the library installed on the user's computer. For example, if the user has version 1 of the numpy library, but my program was developed using numpy version 2, we would have to either install version 2 numpy on the user's computer or use already installed version 1 numpy which could cause errors.

## Game Objects and Classes

The code in the project will be split into classes for the ease of testing and readability. Most classes will just encapsulate the methods and the properties related to them, for example, there will be a game state class, which will contain functions which operate on the state of the game, e.g. methods that arrange the balls into their initial triangular position at the start of the game.

There will also be separate classes for every game object in the game. For example, the ball class (figure 13) will be split in 4 different classes - the mathematical part of the ball, which will have things like the position and velocity vector as well as methods which allow to apply a force to the ball. Then there will be 2 types of ball sprites - balls with solid color and balls with a stripe. Finally, there will be a ball sprite class which has an instance of the mathematical ball and one of the sprite classes. I decided to go with the rule of thumb "composition over inheritance" and create instances of those classes in the main sprite class instead of inheriting them. Double inheritance is possible in Python, however it introduces ambiguity and unneeded complexity.

![Ball object classes](figures/object_diagram_ball2.png)

## Input Validation

When a player is allowed change the game state, we must make sure that the player won't abuse anything with these rules:

* When the player is allowed to move the ball, check that the player does not move the ball outside of the game border or into another ball.
* When the player is using the cue, it must not extend indefinitely (there should be a reasonable limit on the extension).
* The players should not be allowed to move the white ball out of the white line region on the first hit.

# Technical solution

Disclaimer: the rotation_matrix function in physics.py was taken from https://stackoverflow.com/a/6802723

To be more productive and avoid code loss situations, I decided to use version control. Specifically git, which is the most popular version control framework [@versioncontrol]. Storing a git repository exclusively on a local machine is dangerous since in case of a disk failure all data is lost. To ensure this never occurs, I regularly uploaded my code to github, which is a cloud service which allows storing git repositories on their server. For complex mathematical operations, I used numpy, a numerical library for python which in addition to a wide range of scalar functions provides a multitude of vector functions. For executing tests I used pytest, a popular python unit-testing library. I also set up a simple continuous integration pipeline which runs all of my tests on a git-push to github. For this I used the Travis CI service. Finally, for managing dependencies I chose pip (all project requirements are specified in requirements.txt), which is a common dependency manager used for python.

To make the projects code easier to read, the code will be split into different files. In general, each file (or module) will have a single class or a single game object associated with them. Each such module could be later imported in other files.

## Bugs Fixed During Development

### "Reverse" Shot Bug

If the cue is brought very close to the white ball, the game sometimes applied the force in the other direction on the ball, meaning the ball would move towards the ball after the hit.

```
new_velocity = -(self.displacement - config.ball_radius - config.cue_safe_displacement) * \
        config.cue_hit_power * np.array([math.sin(self.angle), math.cos(self.angle)])
```

The game calculated the new velocity of the ball using this formula. `self.displacement` is the displacement of the cue from the centre of the ball, `config.cue_safe_displacement` is the distance from the ball the cue could be displaced and released without affecting the ball. Here is the if statement which check if a ball hit went through.

```
if self.displacement > config.ball_radius:
    self.ball_hit()
```

The if statement was missing the `config.cue_safe_displacement`, therefore if the cue was brought really close to the ball and if the value of `config.cue_safe_displacement` was bigger that zero, `self.displacement - config.ball_radius - config.cue_safe_displacement` could be less than zero and so reverse the direction of the hit.

Code changed (pool/cue.py line 114)[@reverseshotcommit]:

```
-        if self.displacement > config.ball_radius:
+        if self.displacement > config.ball_radius+config.cue_safe_displacement:
            self.ball_hit()
```

This change will insure that `self.displacement - config.ball_radius - config.cue_safe_displacement` will be bigger than zero, thus fixing the bug.

### Collision Resolution Bug

Sometimes, during the play of the game, the balls would "stick" to each other. Turns out there was a problem with the resolution of the collision, or more precisely, when it was triggered.

Collisions are checked for every frame. Figure 18 shows a possible position of the balls 1 frame before the collision and figure 19 shows the same balls in the next frame. The problem is caused by the ball overlap. When the balls collide, there will be some overlap and if the balls are moving quickly, the overlap might be significant.

![one frame before the collision](figures/ball_overlap1.png)

![collision](figures/ball_overlap2.png)

Because the collision is inelastic the balls will lose some kinetic energy, therefore they will be moving slower after collision (as shown on figure 20).

![one frame after the collision](figures/ball_overlap3.png)

After colliding and moving once (one frame) the balls can still overlap, and thus the collision detection algorithm will trigger in the next frame again. If collision resolution algorithm is called on balls which are moving away from each other, the vectors will be reversed, and on the next frame the balls will be moving towards each other, making the process repeat indefinitely, which in turn makes the balls stick.

![vectors with dot product](figures/ball_collision3.png)

To resolve the collision properly we will take the dot product of the difference between the centres of 2 balls (labeled _distance diff_ on figure 21) and the velocity difference vector (labeled as _v1-v2_). If the result is positive that means that the balls are moving towards each other and we need to reverse their velocities, otherwise we keep the velocities as they are.

__Code changed__:

Added the dot product check in function *collide_balls*[@ballcollisioncommit]:

```
+def collide_balls(ball1, ball2):
+    point_diff = ball2.pos-ball1.pos
+    system_velocity = ball1.velocity-ball2.velocity
...
+    if np.dot(point_diff,system_velocity)>0:
..
```

Later reworked into:

```
def ball_collision_check(ball1, ball2):
    # distance check followed by checking if either of the balls are moving
    # followed by vector projection check, to see if both are moving towards
    # each other
    return distance_less_equal(ball1.pos, ball2.pos, 2 * config.ball_radius) and \
        np.count_nonzero(np.concatenate((ball1.velocity, ball2.velocity))) > 0 and \
        np.dot(ball2.pos - ball1.pos, ball1.velocity - ball2.velocity) > 0
```

## main.py

```{r engine='bash', comment='', echo=F}
cat pool/main.py
```

## physics.py

```{r engine='bash', comment='', echo=F}
cat pool/physics.py
```
## gamestate.py

```{r engine='bash', comment='', echo=F}
cat pool/gamestate.py
```


## collisions.py

```{r engine='bash', comment='', echo=F}
cat pool/collisions.py
```

## ball.py

```{r engine='bash', comment='', echo=F}
cat pool/ball.py
```

## cue.py

```{r engine='bash', comment='', echo=F}
cat pool/cue.py
```

## graphics.py

```{r engine='bash', comment='', echo=F}
cat pool/graphics.py
```

## table_sprites.py

```{r engine='bash', comment='', echo=F}
cat pool/table_sprites.py
```

## event.py

```{r engine='bash', comment='', echo=F}
cat pool/event.py
```

## config.py

```{r engine='bash', comment='', echo=F}
cat pool/config.py
```

## README.md

This file is written in Markdown for aesthetical reasons, I am going to copy the text version of the file without the formatting. To view the Markdown version, please visit - `https://github.com/max-kov/pool/blob/master/README.md`


```
Pool

A pool game written entirely in python!

Features

Realistic collisions based on a two-dimensional Newtonian model.
Simple configuration file (config.py) with many changeable options like ball size,
ball colour, cue length/thickness and many more.
Algorithms which render ball sprites using rotation matrices.
Tests for collision functions and other math related functions.
A small and configurable game menu.

Installing
Dependencies

The pool game requires python 3.5 with modules which are listed in requirements.txt .
Installing on debian-based linux distributions

Install python 3.5 with pip, venv and pygame dependencies

sudo apt-get build-dep python-pygame
sudo apt-get install python-dev python3 python3-pip python3-venv

Then, clone the github code and run the game using run.sh, which will setup a virtual
python environment with the aforementioned modules.

git clone git://github.com/max-kov/pool.git
cd pool
./run.sh

If the pygame installation fails, it's most likely due to apt not having any URIs in
sources.list file. To fix execute

sudo sed -i -- 's/#deb-src/deb-src/g' /etc/apt/sources.list && sudo sed -i -- 's/#
deb-src/deb-src/g' /etc/apt/sources.list
sudo apt-get update

and run the installation procedure again.
Windows

Download python 3.5 with pip then add python to the path variable and run

python -m pip install -r requirements.txt

in the administrator cmd in the game folder to install the dependencies. Finally,
start main.py to run the game. You might have to use python3 instead of python
depending if you have python2 installed. To check that you are using the right
vesrion, write python in the console to see what version is used.
Running the tests

You can always see the results of the latest build here. If you want to run the
tests yourself, we will need extra modules. (On linux) Run

pip3 install -r test_requirements.txt

in the game folder to install the testing modules. To run the tests write

PYTHONPATH=./pool pytest tests/

You can also check test coverage by executing

PYTHONPATH=./pool pytest --cov=. tests/

That will analyse which files and which lines of code were executed by the tests.
.coveragerc will prevent the module from analysing test files as well.
Built With

Python 3.5
Pygame - 2d graphics library
Numpy - Scientific computing library, used here for vector opertations
Travis CI and CodeClimate - Testing and code analysis
```

# Testing

## Unit Testing
In my game there are two main things to test - the process of the physical simulation, meaning the mathematics behind the collisions, collision detection and others, and the user interface. To test the mathematics, I've made a set of tests in a form of a script, which when executed runs the main program with the test input data. These tests are considered white box testing, more specifically, unit testing because I am testing specific functions of the program.

To make the job of testing the game with every change easier, I am using a continuous integration servive (TravisCI) which executes the unit tests on my code every time I make a commit to GitHub. The unit tests are included with the game in the folder “tests”.

The tests work by executing a function from the pool game with a specific input and then comparing the result of the computation to a set value which is known to be correct.

```
def test_point_distance1(self):
    assert physics.point_distance(np.array([0, 0]), np.array([3, 4])) == 5
```

The test calls the function responsible for calculating the distance between two points, with points (0,0) and (3,4), and compares it to 5. If the function does not return 5, the test returns an exception because the function did not return the right value.

Here is another, more complicated example of an edge case test (Figure 18):

```
def test_movement4(self):
    ball1.set_velocity((1, 1))
    ball2.move_to(-fortyfive_degree_position)
    ball2.set_velocity((1, 1))
    assert not physics.ball_collision_check(ball1, ball2)
```

![Edge case collision test](figures/test1.png)

The test sets the balls such that they are touching, however, both balls are moving with the same velocity. That means there is collision, but there is no need for it to be resolved (explained in Technical Solution - Bugs Fixed During Development).

This is an example of an extreme test (Figure 19):

```
def test_movement10(self):
    ball1.set_velocity((0, 1))
    ball2.move_to((0, ball_radius * 2))
    ball2.set_velocity((200000000, -200000000000))
    assert physics.ball_collision_check(ball1, ball2)
```

The values in the test are exaggerated so that we know that the game can handle extreme values.

![test2](figures/test2.png)


### Test files


```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/test_files.csv", header=TRUE, sep=","), split.table = Inf)
```

Here are the test files:

#### test_ball_line_collision.py
```{r engine='bash', comment='', echo=F}
cat tests/test_ball_line_collision.py
```

#### test_ball_ball_collision.py
```{r engine='bash', comment='', echo=F}
cat tests/test_ball_ball_collision.py
```

#### test_distance.py
```{r engine='bash', comment='', echo=F}
cat tests/test_distance.py
```

#### test_rotation_matrix.py
```{r engine='bash', comment='', echo=F}
cat tests/test_rotation_matrix.py
```

#### test_triangle_area.py
```{r engine='bash', comment='', echo=F}
cat tests/test_triangle_area.py
```

### How To Run the Tests

To run the tests on Linux, run `PYTHONPATH=./pool pytest tests/` in the terminal in the game folder. Here is me running the tests on my machine on the latest pool build.

```
========================= test session starts ==========================
platform linux -- Python 3.6.4, pytest-3.2.3, py-1.5.2, pluggy-0.4.0
rootdir: /home/max/code/python/pool, inifile:
plugins: cov-2.5.1, asyncio-0.8.0
collected 30 items                                                      

tests/test_ball_ball_collision.py .................
tests/test_ball_line_collision.py ......
tests/test_distance.py ...
tests/test_rotation_matrix.py ..
tests/test_triangle_area.py ..

====================== 30 passed in 0.21 seconds =======================
```

Tests for other builds on the GitHub repository page [@githubrepo]. The records of how the build passes the tests are available on the GitHub commit history page^[https://github.com/max-kov/pool/commits/master] or on Travis-CI^[https://travis-ci.org/max-kov/pool/builds].



## Conventional Tests

Unlike the automatic unit testing mentioned earlier, these tests will be done by me playing the game.

Normally, in this section candidates test their projects and add the proof in the form of screenshots. With my project, however, it is hard to understand what is going on in the game only through screenshots, so I recorded a gameplay video, doing every test outlined in GUI, Collisions and Game rules sections (I will only mention the gameplay video as proof only when screenshots can't be used to show the outcome of the test). The video is hosted on youtube - `https://www.youtube.com/watch?v=rg0-kHyMUhQ`.

The proof for the last 2 tests in the Configuration File section references the second gameplay video - `https://www.youtube.com/watch?v=RlY_nydxog0`.


### GUI

In this section I will be testing the graphical user interface component of the game and the possible interactions the user might have with it.

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/gui.csv", header=TRUE, sep=","), split.table = Inf)
```

### Collisions

Collisions were thoroughly tested using automated unit tests, but just to be sure, I will check what they look like in game.

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/collisions.csv", header=TRUE, sep=","), split.table = Inf)
```

### Game Rules

This is the section concerning the rules of the game.

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/game_rules.csv", header=TRUE, sep=","), split.table = Inf)
```

#### "Winning by illegally potting the 8ball" bug fix

The 1st test in the table failed, meaning if a player potted the 8ball illegally, he won the game instead of loosing it.

Fortunately, the bug was a simple mistype in one of the if statements which decided who won the game. Here is the piece of code responsible for the bug.

```
def check_potted(self):
    self.can_move_white_ball = False  # if white ball is potted, it will be created again and placed in the middle
    if 0 in self.potted:
        self.create_white_ball()
        self.cue.target_ball = self.white_ball
        self.potted.remove(0)
        self.turn_over(True)
    if 8 in self.potted:
        if self.potting_8ball[self.current_player]:
            self.game_over(self.current_player == Player.Player1)
        else:
            self.game_over(self.current_player == Player.Player1)
```

`Check_potted` is the function which checks the potted balls after the round is over. If the game finds the 8 ball in the potted balls list, it checks if the current player (who potted the 8ball) has the right to do so and calls the `game_over` function. The function `game_over` receives one boolean parameter - `p1_won`, which indicates whether the first player won the game (we can deduce that if the first player did not win the game, the second player must have won the game, so only one boolean parameter is needed). If the current player had the right to pot the 8 ball the `game_over` function is executed with `self.current_player==Player.Player1`. It passes that boolean because the current player won the game, so if the 1st player potted the 8ball the function would be executed with a `True` and is the 2nd player potted the 8ball the function would be executed with a `False`.

The bug, hovewer, lies in the `else` clause. If the current player did not have the right to pot the 8 ball, the `game_over` function is still executed with the same parameter, meaning the player who potted the 8 ball wins the game, even if the action was illegal. To fix the bug, we have to change the "equal to" operator to "not equal to".

Changed code:
```
def check_potted(self):
    ...
    if 8 in self.potted:
        if self.potting_8ball[self.current_player]:
            #current player wins
            self.game_over(self.current_player == Player.Player1)
        else:
            #current player loses
            self.game_over(self.current_player != Player.Player1)
```

#### Configuration file

In this section I will test the configuration file `config.py` by changing the corresponding values in the file.

```{r echo = FALSE, results = 'asis'}
pander(read.table("tables/configuration_file.csv", header=TRUE, sep=","), split.table = Inf)
```

![The menu before hovering over the button](testing/menu1.png)

![The menu while hovering over the button](testing/menu2.png)

![Ball break 1/3](testing/break1.png)

![Ball break 2/3](testing/break2.png)

![Ball break 3/3](testing/break3.png)

![Potting the teal ball 1/4](testing/pot1.png)

![Potting the teal ball 2/4](testing/pot2.png)

![Potting the teal ball 3/4](testing/pot3.png)

![Potting the teal ball 4/4](testing/pot4.png)

![Attempting to put the ball into the another ball](testing/ball_movement1.png)

![Attempting to put the ball into the wall](testing/ball_movement2.png)

![Attempting to put the ball into the pocket](testing/ball_movement3.png)

![Potting the 8ball illegally 1/4](testing/illegal_8ball_pot1.png)

![Potting the 8ball illegally 2/3](testing/illegal_8ball_pot2.png)

![Potting the 8ball illegally 3/3](testing/illegal_8ball_pot3.png)

![Potting the 8ball legally 1/3](testing/legal_8ball_pot1.png)

![Potting the 8ball legally 2/3](testing/legal_8ball_pot2.png)

![Potting the 8ball legally 3/3](testing/legal_8ball_pot3.png)

![Potting a ball before the groups have been assigned 1/4](testing/legal_pot1.png)

![Potting a ball before the groups have been assigned 2/4](testing/legal_pot2.png)

![Potting a ball before the groups have been assigned 3/4](testing/legal_pot3.png)

![Potting a ball before the groups have been assigned 4/4](testing/legal_pot4.png)

![Not hitting a single ball in a turn 1/3](testing/nohit_shot1.png)

![Not hitting a single ball in a turn 2/3](testing/nohit_shot2.png)

![Not hitting a single ball in a turn 3/3](testing/nohit_shot3.png)

![Hitting the 8ball 1/4](testing/8ball_hit1.png)

![Hitting the 8ball 2/4](testing/8ball_hit2.png)

![Hitting the 8ball 3/4](testing/8ball_hit3.png)

![Hitting the 8ball 4/4](testing/8ball_hit4.png)

![Hitting a ball from the opposite group 1/4](testing/opposite_group_hit1.png)

![Hitting a ball from the opposite group 2/4](testing/opposite_group_hit2.png)

![Hitting a ball from the opposite group 3/4](testing/opposite_group_hit3.png)

![Hitting a ball from the opposite group 4/4](testing/opposite_group_hit4.png)

![Initial state of the first screen of the game](testing/initial_screen.png)

![Decreased cue_length variable in the configuration file](testing/config_cue.png)

![Increased ball_radius variable in the configuration file](testing/config_balls.png)

![Changed resolution variable in the configuration file](testing/config_resolution.png)

![Increased hole_radius variable in the configuration file](testing/config_pockets.png)

# Evaluation

## Objective Analysis

Here are the objectives set for this project:

* The rules of pool should be implemented in the game
* The game should run at more than 30 frames per second
* Physical interactions in the game should be realistic:
  * The movement of the balls should be affected by friction
  * The ball collisions should be inelastic
  * The game should detect and resolve ball-ball and ball-table side collisions correctly
* Game animations should look realistic:
  * The balls should visibly rotate when moving
  * The cue should move towards the ball when a player is hitting a ball
* There should be a configuration file, which can change some of the in-game options like ball size or cue hit power
* An installation guide/README file for users should be present

Collisions, ball movement and game rules were completed and tested in Testing section[@vid1][@vid2].

The hardest part of the animations in the game was the ball. The stripes on the ball are rendered approximately, meaning the algorithm does not use a large amount of polygons to model the stripe, but because the balls are small in game, this is hardly noticeable[@vid1]. This condition was met.

The game frame per second limit was set to 60 fps, and judging from looks, it runs at steady 60 frames per second without visible tearing. The frame per second limit variable can be changed in the configuration file[@vid1]. This condition was met.

Talking about the configuration file, the configuration options are perhaps too extensive and contain stuff you wouldn't expect, for example, you could change the position of the individual pockets in the file. Even though the file is written in python, users won't need to know python to change these settings, because the file looks like a normal text file. This mostly because of pythons high level syntax which is very close to pseudocode[@vid2]. The configuration condition was met.

The installation guide for Linux and Windows users is included in the README file. Because python has to install the required modules before the game could be played, the installation for windows users requires the command line. For Linux, however, there is a simple shell script which creates a virtual environment, installs the required modules, and starts the game.This condition was met.

Therefore, all objectives were met.


## User Feedback

I have interviewed my classmate again after he installed and played the game on his machine.

__Was the game easy to install?__

_Installing the game using the included shell script was as easy as it gets. Just download the repository and run the starting script._

__How was your gameplay experience?__

_The game is simple and has appealing graphics. The collisions and the rules work well. I've had a lot of fun changing the values in the configuration file too see how the game would behave._

__Did you encounter any bugs or errors?__

_Not in the normal play mode, no. After changing some of the values in the configuration file the game became unplayable, for example, I made the balls bigger than the pockets and removed movement friction once, and the game did not handle that very well, however I was breaking it intentionally and it's more entertaining if the game allows you to break it. The game ran very smoothly, too._

As expected, the user is satisfied with the solution. One thing to consider, is the fact that the user was using a Linux operating system, which made the process of installing the game easier. The installation process might be more inconvenient on other operating systems.

Besides the interview, the game became surprisingly popular online, gaining traffic on GitHub (see Figure 58) and, at the time of writing this, becoming the first search result on Google for "python pool game", which is, admittedly, a very specific search query.

![Github repository traffic report](figures/github_traffic.png)

## Possible Extensions

Multiplayer for this game is something I would like to implement, but it would to complex for me alone, because it would require good network development knowledge, which I do not have. Additionally, it requires a server to overlook the players' actions and to synchronise both programs and I don't have a dedicated server, too.

One similar feature I would like to implement, but lack the resources to do so, is an AI player. While it is significantly easier to implement AI than multiplayer, after looking into this problem I have not found an easy way to do this. One algorithm for AI which caught my attention was:

1. Find every possible ball on the table you can hit.
2. Check which balls have a direct unblocked path to a pocket.
3. Calculate where the point of contact must be made to hit the ball into that pocket.
4. Calculate the angle of the cue required so that the cue ball would hit the target ball at the correct point of contact.

This is a fairly simple algorithm but there are several problems with it. Firstly, it's not trivial to find the list of balls you can hit, without hitting another ball. One way to do that is - whenever you are checking a particular ball, see if any other balls between the cue ball and the target ball. In terms of speed, that is would be $\mathcal{O}(n^2)$, because the algorithm would have to iterate through every ball for every ball. Same for checking if the ball has an unblocked path to the pocket. Another way to implement this would be machine learning algorithms, but these are famous for requiring high level mathematics knowledge which I lack.

Another design choice which could be improved is the stripe rendering algorithm. The problem with the algorithm is that it is an approximation and can be wrong when looked into very carefully.

![A picture of a rotated ball in-game](figures/ball_screen1.png)

![A picture of balls in-game](figures/ball_screen2.png)

In real life the stripe on the top of the ball would look a bit thicker than on the sides (see Figure 59), but it is of constant width in-game. This is because the stripe on the top is slightly closer to the observer and thus takes up a bigger section of their vision. To generate the stripe properly, I would have to consider the change of distance when the ball is rolling. Also, and perhaps more noticeably, the game doesn't use polygons to model the stripes, which makes the line look a bit rough on the edges (Figure 60).

Finally, as seen in the User Feedback section of this chapter, the user had no problems installing the game, however that is mostly because the user was using a Linux-based operating system. The installation for Windows users is harder because they have to install the libraries themselves. The installation aspect may be improved by making a special Windows game installer which would allow the game to be installed without (or minimal) user interaction.

# References
