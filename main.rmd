---
title: Computer Science project.
author: Maksims Kovalovs
output:
  html_document:
        toc: true
        toc_depth: 2
        toc_float: true
        theme: paper
bibliography: references.bib
link-citations: yes
csl: refstyle.csl
---

# Analysis

## Introduction

This project is about making a 8 ball pool game with a top down view. The game will:

* be played by 2 people on a single computer
* use the standard pool rule set
* have ball animations (should visibly rotate)
* have realistic physical interactions (ball collisions and friction)

Therefore, this project will deal with 3d rendering, physical simulation and game development areas of computer science.

## Identification of End Users

The main end users of this project are my school friends who are interested in playing a computer version of pool.
My project will be hosted on GitHub[@githubrepo], so other people can play the game for free.

## Evidence of analysis

To better understand the problem I had to solve, I decided to interview one of my sixth form classmates about it:

__What are the problems with the current system?__

_We were supposed to have a pool table installed in the common room this year, but the student union didn't have enough money to do that. Our group has a lot of free time in school, and we really want to play pool against each other, even if it's on a computer._

__Have you found anything online which works as you want?__

_We have found some pool games online, but most of them are player vs AI and require internet connection, which, unfortunately, you can't take for granted. In our case we don't really need to be able to play via the internet, an offline game should be fine._

__Is there anything specific you want in the game?__

_A normal pool game with rules for 2 players should suffice. It shouldn't be too slow or lag. Obviously, the balls and their movement should look like in real life. It would be interesting to have a sandbox or something which allows the user to tweak with the game options like cue hit power or the ball size._

The user asked for standard features for this game, except for the sandbox mode. That can be achieved in different ways, like an in-game GUI or a configuration file, which is present in many new games. Other than that request, the user needs mostly reflect ones outlined in *Introduction*.

## Objectives

* The rules of pool should be implemented in the game
* The game should run at more than 30 frames per second
* Physical interactions in the game should be realistic:
  * The movement of the balls should be affected by friction
  * The ball collisions should be inelastic
  * The game should detect and resolve ball-ball and ball-table side collisions
* Game animations look realistic:
  * The balls should visibly *rotate* when moving
  * The cue should move towards the ball when a player is hitting a ball
* A configuration file, which can change some of the in-game options like ball size or cue hit power

## Proposed Solution

### Language Choice
At the beginning of the project, I was experienced in two programming languages - Python and Pascal. To pick one, I had to do some research on their suitability for the job.
According to the Tiobe Index[@tiobe] and PYPL[@pypl], Python is significantly more popular than Pascal and hence is a better language to use due to more resources available online (e.g. more StackOverlow questions/answers). This also suggests that python will have higher quality/variety of libraries due to a larger community. Additionally, Python is a duck-typed language, which means no explicit type declarations are required. This makes Python less verbose and more flexible, allowing for faster development, which is beneficial given a limited amount of time for development. Finally, a game development library will be at the core of my project so it is important to pick a language with a mature, well maintained game development framework.
A number of resources list the most popular libraries used for implementing games in Pascal[@fpcgameengine][@delphigamedev]. All of these libraries are either missing completely (home page is broken), seriously outdated or are very immature. At the same time, Python has Pygame[@pygamegithub] which is open source, actively maintained (at the time of writing last commit 3 days ago) and mature (3k commits with 40 contributors).

### Pool Rules
To implement the rules of pool I had to go online and read about the game rules[@poolrules], here are the main points:

* The first break should be performed behind the white line on the table, and the ball may be placed anywhere behind that line.
* If the players haven't decided which group of balls they are on, and the player pots a ball or several balls of a particular group, that player now is on that group.
* To win the game, you must pot the 8 ball legally.
* You must first sink every ball from the group you are on, to pot the 8 ball.
* Failure to hit a ball from your group on your first ball hit, or not hitting a ball at all on your turn, gives your opponent a hit *from his hand* (which means that he is allowed to put the white ball anywhere on the table)
* If you pot the 8 ball illegally, you lose the game.

### Collisions
There will be 3 types of collision - ball-ball, ball-table side and ball-pocket. Every frame the game will check for these collisions, and if it detects any, it will resolve the collision based on the velocity and the position of the balls using linear algebra and vector operations. To model ball-ball and ball-table side collisions I will use the inelastic collision formula[@inelasticcollision]. The formula depends on the *coefficient of restitution* - $e$, whose values range from 0 to 1 (1 being a perfectly elastic collision and 0 perfectly inelastic). Low values of $e$ mean that there is a lot of kinetic energy lost in collision and visa versa.

Ball-pocket collisions are much more straight forward - as soon as such a collision is detected, the ball is removed from the game.

### Rendering
Some parts of the balls (like the white stripe around the balls) will be modeled as 3d objects, rotated using rotation matrices when the ball is moving and then projected on the table (into a 2d space).

### Cue
The cue will be modeled as rectangle, which the player can click and draw to perform a hit. The power of the hit will be proportional to the displacement of the cue from the ball.

### Friction
To model rolling friction I will use the formula $F=C_{rr}N$ where $C_{rr}$ is the coefficient of rolling resistance of the balls[@rollingfriction]. That means the balls will have a constant frictional force on them (when they are moving).

# Documented design

## Algorithms

### Rendering

The ball can be split in 3 parts which must be rendered separately:

* The ball stripe
* The label (circle with the number)
* The solid color body

![Initial position of the ball](figures/ball1.png)

![A possible position of the ball](figures/ball2.png)

A sphere of a solid color will look like a circle from any angle in 2-dimensions. That's why we don't need to worry about any rotations of the solid sphere component. Hence we can just draw the solid body as a solid circle and draw everything else on top.

The stripe on the ball will be modeled as an array of 3-dimensional points. When the ball moves the points are rotated using rotation matrices. The 3d matrix is calculated from an axis and an angle. We know the axis of rotation - it is the line perpendicular to the velocity vector and parallel to the table surface, and the angle of rotation is calculated using the formula
$$
\theta=\frac{vt}{r}
$$
where $v$ is the linear speed of the ball and $r$ is the radius of the circle with $\theta$ being in radians. The intuition for the formula is that when the ball is moving, every point on the circumference must touch the ground before it does a full rotation, therefore it must move $2\pi r$ units for a full rotation. The angle the ball has rotated is therefore given by $\frac{S}{r}$, where $S$ is the linear distance the ball has traveled. Then we substitute the formula $S=vt$ to get the aforementioned formula.

The rotation matrices are calculated using the Euler–Rodrigues formula. The rotated vector $\vec x$ is calculated according to this formula:
$$
\vec x\prime =
\begin{bmatrix}
    a^2+b^2-c^2-d^2 & 2(bc-ad) & 2(bd+ac) \\
    2(bc+ad) & a^2+b^2-c^2-d^2 & 2(cd-ab) \\
    2(bd-ac) & 2(cd+ab) & a^2+b^2-c^2-d^2
\end{bmatrix}
\vec x
$$

Where $a,b,c,d$ are

\begin{gather*}
a = cos(\frac{\phi}{2}) \\
b = k_{x}sin(\frac{\phi}{2}) \\
c = k_{y}sin(\frac{\phi}{2}) \\
d = k_{z}sin(\frac{\phi}{2})
\end{gather*}

With $\phi$ being the rotation angle and $\vec k=(k_{x},k_{y},k_{y})$ being the unit vector of the axis of the rotation[@matrixmathworld][@stanfordhandout1][@stanfordhandout2].

Every frame the rotation matrix is calculated and applied to every point in the line array. When the line is drawn, if the z-axis value of a point is less than $0$, the point is ignored. That is because that point is *under* the ball, and cannot be seen from a top-down view. Then, we have matrix $a$ where $\vec k$ are the points with $z\geq0$
$$
a=
\begin{bmatrix}
    \vec k_{1} & \vec k_{2} & \vec k_{3} & \dots & \vec k_{n}
\end{bmatrix}
$$

We will draw lines from $\vec k_1$ to $\vec k_2$, from $\vec k_2$ to $\vec k_3$ and so on for every pair of numbers (a line from $\vec k_{i-1}$ to $\vec k_{i}$ for $i\in[2,n]$). This will trace the points with lines, drawing the stripe on the ball.

The label will be tracked with a single point. That point will be on the top of the ball when it's initialised and will be rotated with the same rotation matrix outlined earlier. Additionally, the label will be compressed or *squashed* depending on its position on the circle. For example, when the label is on the circumference of the ball, the width of the label sprite is squashed to values close to 0. To get the scale factor of this transformation, I will use the formula $SF=rd$, where $r$ is the radius of the ball, and $d$ is the distance of the label to the edge of the ball from the top-down view. One important thing to note is that this is a __heuristic__ method. This technique produces believable results, but isn't how it exactly works in real life. One method which would produce better results is __surfel__ modeling[@surfel], but implementing something that complex is out of the scope of this project.


### Collision detection

#### Ball-ball and ball-pocket

Because pockets are modeled as circles, we use the same algorithm to detect collisions for both balls and circles.

One way detect a ball-ball collision is to check the distances between every ball every frame and, if the distance between two balls is less than the sum of their radii, that means that they have collided.

![](figures/ball_collision1.png)

#### Ball-line

![](figures/lineballcollision1.png)

To detect such a collision we need to get the perpendicular distance from the ball to the line.

![](figures/lineballcollision2.png)

We know the position of the ball centre, its radius, and 2 points (p1 and p2 on the figure) which define the line. First we find the unit vector of the line (vector from p1 to p2) and the distance vector from one of the points to the ball centre (blue line on the figure). Then we get the distance from p1 to the perpendicular projection point using the _dot product_ on the aforementioned vectors. Note that the result will be a scalar quantity. To get the actual projection point we multiply the scalar value by the unit line displacement vector we got earlier to get the _projection point_ (as labeled on the figure). Then we can get the perpendicular distance from the line to the ball centre by using Pythagorean theorem. We can compare the distance to the balls radius to determine if the ball is colliding with the line.

However there is one final caveat:

![](figures/lineballcollision3.png)

it's possible for the projected point to be outside of the line. To check that its not the case, we check that the distance from p1 and p2 to the projected point is less than the length of the line (distance from p1 to p2).

### Collision resolution

#### ball-pocket

In my game, any ball which has its _centre of mass_ inside a pocket is considered potted and is instantly removed from the game. Therefore, the algorithm only needs to check if the distance from the centre of the ball to the centre of the pocket is smaller than the radius of the pocket, and if it is, the ball is removed.

#### ball-line:

This collision is called ball-line, because the table walls are modeled as lines. When a ball collides with a line the perpendicular component of the balls velocity to the line is reversed and multiplied by $\frac{1+e}{2}$. The component parallel to the line is unchanged. This is because the force from the wall on the ball is applied strictly perpendicularly to the line.

#### ball-ball:

If we get the projections of the velocity of the ball onto the vector which goes from the centre of the first circle to the second circle, we see that only one of the components of the velocity will be affected (only _V1_ will be changed on the figure). This is because there is only 1 point of interaction between the balls, meaning any forces will have to go from the centre of mass of a ball, through that point.

![ball collision example](figures/ball_friction1.png)

The result is that we can use 1-dimensional collision formulas here, even though we have a 2-dimensional collision. We do that by only considering the velocity component which goes through the collision point (_V1_) and leave the other velocity component unchanged (_V2_ on the figure).

The general formula for a 1-dimensional collision is[@inelasticcollision]:
$$
V'_1=\frac{(1+e)M_1}{M_1+M_2}V_2
$$
Where $e$ is the coefficient of restitution (explained in analysis), $M_1$ and $M_2$ are the masses of the first and second balls, respectively. $V'_1$ is the velocity of the first ball after the collision and $V_2$ is the velocity of the second ball prior to the collision.

In our case, the masses of the balls are all the same, which gives us:
$$
V'_1=\frac{(1+e)}{2}V_2
$$
To summarise, we split the ball velocities into 2 vectors: one vector - $V_a$, which goes through the collision point and the other vector - $V_b$, which is at 90 degrees to the first vector , then the formula for the velocity after the collision is:
$$
V'_1=\frac{(1+e)}{2}V_{a2}+V_{b1}
$$

### Cue stick click detection

Because the cue stick is modeled as a rectangle, the problem here can be simplified down to figuring out if a 2d point is in a rectangle (which is defined with 4 2d points). To do that we find the area of 4 triangles which can be made with 4 rectangle points and the points. We can find the area of triangles using herons formula.

![click inside cue](figures/cue1.png)

The area of the green triangles equals the area of the cue, therefore the click is inside the cue.

![click outside cue](figures/cue2.png)

The user clicks on the blue dot which is outside the black cue. The sum of the ares of the green triangles is greater than the area of the cue, thus the point is outside of the cue.

### The main game loop

Pseudocode:
```
While not_closed:
    button_pressed_in_main_menu = main_menu_get_button()

    if button_pressed_in_main_menu == "Play_button":
        While not_closed or game_is_over():
            resolve_collisions()
            do_one_frame()

            If all_balls_not_moving():
                check_pool_rules()
                use_cue()

    if button_pressed_in_main_menu == "Exit_button":
        not_closed=False
```

This is the whole game split into functions. Every turn, one player uses the cue, then while the balls are moving, the game will check for any collisions, resolve them and do *one frame*, meaning it will move every moving object and redraw everything. The main game loop will continue doing that until the game is over or the game is closed.

## User Interface

 Judging from other computer games, the pool game should include these things:

* The game screen should be big enough to see everything clearly.
* The balls should look realistic, and have easily distinguishable stripes on them so the players would not be confused which balls they need to pot.
* The game should have aiming lines to help the player aim. These lines are needed because in real life the player can line up the ball and see where it will go, so the game should have similar functionality.
* The game should have a border so that the cue stick could be used even if the ball is in a corner.
* The game should have a minimal game menu.

![main menu model](figures/main_menu.png)

In-game interface will consist of the cue, which can be aimed and retracted back to make a shot. The game will also have some indicators of the state of the game:

* A "current player" indicator (which can just be a label on the top)
* An indicator of which balls the players need to pot to win the game
* An indicator of whether the current player can move the cue ball

![UI example figure](figures/ui_example1.png)

### Controls

* The game should be almost fully controlled through the cue stick to hit the balls. The cue will be interactive via the mouse. An exception to the previous rule is if the white ball was potted and it must be moveable. In that case the ball can be interacted with via the mouse, specifically if the game rules allow the ball to be moved the player can click the ball and move it.
* In the menu the main input method is the mouse, however the user should be able to quit the game by pressing ESC key.
* While in game, the user should be able to press the ESC button to close the game.

### Modular Design

* Main menu
  * The game
    * Stop the game
    * Game over
  * Quit the game

## Game objects and classes

The game will be split into objects. There will be a main *game_state* class, which contains properties and methods which are related to the state of the game.

![game_state](figures/object_diagram_gamestate.png)

Every object game object will have its own class.

![cue](figures/object_diagram_cue.png)

![ball](figures/object_diagram_ball.png)

![table sprites](figures/object_diagram_tablesprites.png)

There will also be supplementary classes, which are used by the game_state class.

![events](figures/object_diagram_event.png)

![graphics](figures/object_diagram_graphics.png)

## Processing  considerations

* The balls will have a velocity and position vector. The velocity vector will be added to the position vector every iteration.
* There will be collision functions for ball-ball collisions and ball-table side collisions.
* The balls will have a function which will generate the ball sprite depending on the position and the movement of the ball.
* Functions which are responsible for checking that the game rules are not broken.

![game flow](figures/game_flowchart.png)

## Input Validation

When a player is allowed change the game state, we must make sure that the player won't abuse anything with these rules:

* When the player is allowed to move the ball, check that the player does not move the ball outside of the game border or into another ball.
* When the player is using the cue, it must not extend indefinitely (there should be a reasonable limit on the extension).
* The players should not be allowed to move the white ball out of the white line region on the first hit.

# Technical solution

## collisions.py

```{r engine='bash', comment='', echo=F}
cat pool/collisions.py
```

## ball.py

```{r engine='bash', comment='', echo=F}
cat pool/ball.py
```

## config.py

```{r engine='bash', comment='', echo=F}
cat pool/config.py
```

## cue.py

```{r engine='bash', comment='', echo=F}
cat pool/cue.py
```

## event.py

```{r engine='bash', comment='', echo=F}
cat pool/event.py
```

## gamestate.py

```{r engine='bash', comment='', echo=F}
cat pool/gamestate.py
```

## graphics.py

```{r engine='bash', comment='', echo=F}
cat pool/graphics.py
```

## main.py

```{r engine='bash', comment='', echo=F}
cat pool/main.py
```

## physics.py

```{r engine='bash', comment='', echo=F}
cat pool/physics.py
```

## table_sprites.py

```{r engine='bash', comment='', echo=F}
cat pool/table_sprites.py
```

# Testing

## Bugs fixed during the development of the program

### "Reverse" shot bug

If the cue is brought very close to the white ball, the game might think that the cue stick is inside the ball. That results into negative displacement, which when then produces a negative force on the ball (because the force from the cue on the ball is calculated based on it's displacement from the ball).

Code changed (pool/cue.py line 114)[@reverseshotcommit]:

```
-        if self.displacement > config.ball_radius:
+        if self.displacement > config.ball_radius+config.cue_safe_displacement:
```

The new variable `config.cue_safe_displacement` is defined in the configuration file, and defines how far the cue can be displaced, before the ball will be affected. For example, if the user displaces the cue by 10 units, but and `config.cue_safe_displacement` is 15, if the user releases the cue, the ball will be unaffected, and the cue will be returned into its initial position.

### Collision resolution bug

Sometimes, during the play of the game, the balls would sometimes "stick" to each other. Turns out there was a problem with the resolution of the collision, or more precisely, when it was triggered.

The problem is caused by when 2 balls overlap. When the balls collide, there will inevitably will be some overlap, at least because of rounding errors. If the balls are moving quickly, the overlap may be significant.

![](figures/ball_overlap1.png)

![collision with overlap](figures/ball_overlap2.png)

Because the collision is inelastic one of the balls (or both) will lose some kinetic energy, and will therefore will be moving slower than before. If the balls are moving approximately towards each other, both of the balls will be moving slower.

![collision with overlap](figures/ball_overlap3.png)

Because of this loss of velocity, sometimes after colliding and moving once (one frame) they will still be inside each other, and thus the collision detection algorithm will trigger in the next frame again. If collision resolution algorithm is called on balls which are moving in opposite directions, the vectors will be reversed, and on the next frame the balls will be moving __towards__ each other, making the process repeat indefinitely, which in turn makes the balls stick.

![collision with dot product](figures/ball_collision3.png)

To resolve the collision properly we will take the dot product of the difference between the position vectors of 2 balls (labeled _distance diff_ on the figure) and the velocity difference vector (labeled as _v1-v2_ on the figure). If the result is positive that means that the balls are moving towards each other and we can collide them, otherwise we ignore them.

__Code changed__:

First addition (in function *collide_balls*)[@ballcollisioncommit]:

```
+def collide_balls(ball1, ball2):
+    point_diff = ball2.pos-ball1.pos
+    system_velocity = ball1.velocity-ball2.velocity
...
+    if np.dot(point_diff,system_velocity)>0:
..
```

Later reworked into:

```
def ball_collision_check(ball1, ball2):
    # distance check followed by checking if either of the balls are moving
    # followed by vector projection check, to see if both are moving towards
    # each other
    return distance_less_equal(ball1.pos, ball2.pos, 2 * config.ball_radius) and \
        np.count_nonzero(np.concatenate((ball1.velocity, ball2.velocity))) > 0 and \
        np.dot(ball2.pos - ball1.pos, ball1.velocity - ball2.velocity) > 0
```

## White box testing (Unit testing)
In my game there are two main things to test - the process of the physical simulation, meaning the mathematics behind the collisions, collision detection and others, and the user interface. To test the mathematics, I've made a set of tests in a form of a script, which, when executed, runs the main program with the test input data. These tests are considered white box testing, more specifically, unit testing, because I am testing specific functions of the program.
To make the job of testing the game with every change easier, I have made unit tests which are executed on my code every time I make a commit to GitHub. The unit tests are included with the game in the folder “tests”, the tests contain some input, which is used with the functions of the game which are responsible for a specific task. Lets look at a particular example:

```
def test_point_distance1(self):
    assert physics.point_distance(np.array([0, 0]), np.array([3, 4])) == 5
```
This function tests the function responsible for calculating the distance between two points. The function uses the function to calculate the distance between points (0,0) and (3,4), and compares it to 5. If the function does not return 5, the test returns an exception.
Here is another, more complicated example of an edge case test:

```
def test_movement4(self):
    ball1.set_velocity((1, 1))
    ball2.move_to(-fortyfive_degree_position)
    ball2.set_velocity((1, 1))
    assert not physics.ball_collision_check(ball1, ball2)
```

![test1](figures/test1.png)

The test sets the balls such that they are touching, however, both balls are moving with the same velocity. That means there is no collision.

This is an example of an extreme test:

```
def test_movement10(self):
    ball1.set_velocity((0, 1))
    ball2.move_to((0, ball_radius * 2))
    ball2.set_velocity((200000000, -200000000000))
    assert physics.ball_collision_check(ball1, ball2)
```

The values in the test are exaggerated so that we know that the game can handle extreme values.

![test2](figures/test2.png)

### To run the tests

The file contains many tests, including matrix transformation tests, line to ball collision tests and the triangle area test. Here is the file itself:

```{r engine='bash', comment='', echo=F}
cat tests/test_physics.py
```

Here is me running the tests on my machine on the latest pool build.

```
PYTHONPATH=./pool py.test --cov=.
========================= test session starts ==========================
platform linux -- Python 3.6.4, pytest-3.2.3, py-1.5.2, pluggy-0.4.0
rootdir: /home/max/code/python/pool, inifile:
plugins: cov-2.5.1, asyncio-0.8.0
collected 31 items

tests/test_physics.py ...............................

----------- coverage: platform linux, python 3.6.4-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
pool/__init__.py            0      0   100%
pool/ball.py              120     84    30%
pool/collisions.py         26     18    31%
pool/config.py             61      5    92%
pool/cue.py               100     80    20%
pool/event.py              18     12    33%
pool/gamestate.py         210    170    19%
pool/graphics.py           49     38    22%
pool/main.py               31     31     0%
pool/physics.py            44      7    84%
pool/table_sprites.py      77     56    27%
-------------------------------------------
TOTAL                     736    501    32%


====================== 31 passed in 0.39 seconds =======================
```

Tests for other builds and instructions on how to run the tests yourself can be found on the GitHub repository page^[https://github.com/max-kov/pool]. The records of how the build passes the tests are available on GitHub^[https://github.com/max-kov/pool/commits/master] or on Travis-ci^[https://travis-ci.org/max-kov/pool/builds].


# Evaluation

## Objective Analysis

## User Feedback

## Analysis of User Feedback

## Possible Extensions

# References
